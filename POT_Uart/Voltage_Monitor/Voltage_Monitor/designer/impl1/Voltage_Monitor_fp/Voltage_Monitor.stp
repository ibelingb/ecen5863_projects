NOTE "CREATOR" "FlashPro Version: v11.8";
NOTE "CAPTURE" "11.8.0.26";
NOTE "DEVICE" "A2F200M3F";
NOTE "PACKAGE" "A2F200M3F-fg484";
NOTE "DATE" "2020/10/29";
NOTE "TIME" "06:45:29";
NOTE "STAPL_VERSION" "JESD71";
NOTE "VENDOR" "Microsemi Corporation";
NOTE "IDCODE" "05A131CF";
NOTE "IDMASK" "0DFFFFFF";
NOTE "DESIGN" "Voltage_Monitor";
NOTE "DESIGN_DIRECTORY" "E:\repos\ECEN5863_projects\POT_Uart\Voltage_Monitor\Voltage_Monitor\designer\impl1\";
NOTE "CHECKSUM" "7226";
NOTE "SECURITY" "Disable";
NOTE "ALG_VERSION" "20";
NOTE "MAP_VERSION" "1";
NOTE "TOOL_VERSION" "1";
NOTE "MAX_FREQ" "20000000";
NOTE "SILSIG" "00000000";
NOTE "SPEED_GRAD" "STD";
NOTE "TEMP_GRAD" "COM";
NOTE "EXPRESS_CONFIGURATION" "1";
NOTE "PLAYER_VERSION_VARIABLE" "PLAYERVERSIONVARIABLE";
NOTE "PLAYER_VERSION_SW_VARIABLE" "PLAYERVERSIONSWVARIABLE";

ACTION DISABLE_FPGA_ARRAY = 
       VERIFY_IDCODE,
       W_INITIALIZE,
       DISABLE_RLOCK_AND_VERIFY,
       DO_EXIT;
ACTION PROGRAM = 
       VERIFY_IDCODE,
       SET_PRG_ARRAY,
       DO_INITIALIZE_ACCESS_NVM,
       W_INITIALIZE,
       DISABLE_RLOCK_AND_VERIFY,
       DO_ERASE,
       DO_PROGRAM,
       DO_VERIFY_BOL,
       DO_PROGRAM_RLOCK,
       DO_VERIFY_PGM_RLOCK,
       DO_PROGRAM_NVM_ALL,
       DO_VERIFY_NVM_ALL RECOMMENDED,
       RESET_M3 RECOMMENDED,
       DO_EXIT;
ACTION DISABLE_FPGA_ARRAY_PROGRAM = 
       VERIFY_IDCODE,
       SET_PRG_ARRAY,
       DO_INITIALIZE_ACCESS_NVM,
       W_INITIALIZE,
       DO_DISABLE_RLOCK,
       DO_VERIFY_DISABLE_RLOCK,
       DO_ERASE,
       DO_PROGRAM,
       DO_VERIFY_BOL,
       DO_PROGRAM_RLOCK,
       DO_VERIFY_PGM_RLOCK,
       DO_PROGRAM_NVM_ALL,
       DO_VERIFY_NVM_ALL RECOMMENDED,
       RESET_M3 RECOMMENDED,
       DO_EXIT;
ACTION PROGRAM_ARRAY = 
       VERIFY_IDCODE,
       SET_PRG_ARRAY,
       NW_INITIALIZE_ACCESS_NVM,
       AW_INITIALIZE,
       DISABLE_RLOCK_AND_VERIFY,
       DO_ERASE_ARRAY,
       DO_PROGRAM,
       DO_VERIFY_BOL,
       DO_PROGRAM_RLOCK,
       DO_VERIFY_PGM_RLOCK,
       DO_PROGRAM_NVM_PRIV,
       DO_VERIFY_NVM_PRIV,
       RESET_M3 RECOMMENDED,
       DO_EXIT;
ACTION ERASE_ARRAY = 
       VERIFY_IDCODE,
       AW_INITIALIZE,
       DISABLE_RLOCK_AND_VERIFY,
       DO_ERASE_ARRAY_ONLY,
       DO_EXIT;
ACTION ERASE = 
       VERIFY_IDCODE,
       W_INITIALIZE,
       DISABLE_RLOCK_AND_VERIFY,
       DO_ERASE_ONLY,
       DO_EXIT;
ACTION ERASE_ALL = 
       VERIFY_IDCODE,
       INITIALIZE,
       DISABLE_RLOCK_AND_VERIFY,
       DO_ERASE_ALL,
       DO_EXIT;
ACTION VERIFY = 
       VERIFY_IDCODE,
       DO_INITIALIZE_ACCESS_NVM,
       R_INITIALIZE,
       DO_VERIFY_EOL,
       DO_VERIFY_RLOCK,
       DO_VERIFY_NVM_ALL,
       DO_EXIT;
ACTION VERIFY_ARRAY = 
       VERIFY_IDCODE,
       AR_INITIALIZE,
       DO_VERIFY_EOL,
       DO_VERIFY_RLOCK,
       DO_EXIT;
ACTION READ_IDCODE = 
       DO_READ_IDCODE;
ACTION VERIFY_DEVICE_INFO = 
       VERIFY_IDCODE,
       READ_INITIALIZE,
       READ_IDCODE_ONLY,
       DO_VERIFY_DEVICE_INFO,
       DO_EXIT;
ACTION DEVICE_INFO = 
       VERIFY_IDCODE,
       DO_INITIALIZE_ACCESS_NVM,
       READ_INITIALIZE,
       READ_IDCODE_ONLY,
       DO_DEVICE_INFO,
       DO_QUERY_SECURITY,
       DO_EXIT;
ACTION VERIFY_NVM = 
       VERIFY_IDCODE,
       DO_INITIALIZE_ACCESS_NVM,
       NR_INITIALIZE,
       DO_VERIFY_NVM_ALL,
       DO_EXIT;
ACTION VERIFY_NVM_ACTIVE_ARRAY = 
       VERIFY_IDCODE,
       SET_NVM_ACTIVE_ARRAY,
       NR_INITIALIZE_ACCESS_NVM,
       DO_VERIFY_NVM_ALL,
       DO_EXIT_ACCESS_NVM;
ACTION PROGRAM_NVM = 
       VERIFY_IDCODE,
       DO_INITIALIZE_ACCESS_NVM,
       NW_INITIALIZE,
       DO_PROGRAM_NVM_ALL,
       DO_VERIFY_NVM_ALL RECOMMENDED,
       RESET_M3 RECOMMENDED,
       DO_EXIT;
ACTION PROGRAM_NVM_ACTIVE_ARRAY = 
       VERIFY_IDCODE,
       SET_NVM_ACTIVE_ARRAY,
       NW_INITIALIZE_ACCESS_NVM,
       DO_PROGRAM_NVM_ALL,
       DO_VERIFY_NVM_ALL RECOMMENDED,
       DO_EXIT_ACCESS_NVM;
ACTION PROGRAM_NVM_ACTIVE_RSTM3 = 
       VERIFY_IDCODE,
       SET_NVM_ACTIVE_ARRAY,
       NW_INITIALIZE_ACCESS_NVM,
       DO_PROGRAM_NVM_ALL,
       DO_VERIFY_NVM_ALL RECOMMENDED,
       RESET_M3;
ACTION RESET_CORTEXM3 = 
       VERIFY_IDCODE,
       RESET_M3;



DATA CONSTBLOCK;
    INTEGER IEEE1532=0;
    INTEGER STAPL=1;
    INTEGER DIRECTC=2;
    INTEGER PDB=3;
    INTEGER SVF=4;
    INTEGER IAP=5;
    INTEGER FP=0;
    INTEGER FPLITE=1;
    INTEGER FP3=2;
    INTEGER SCULPTW=3;
    INTEGER BPW=4;
    INTEGER DIRECTCP=5;
    INTEGER STP=6;
    INTEGER FP4=7;
    INTEGER FP5=8;
    INTEGER FP33=0;
    INTEGER FP34=1;
    INTEGER FP40=2;
    INTEGER FP41=3;
    INTEGER FP42=4;
    INTEGER FP50=5;
    INTEGER FP51=6;
    INTEGER FP60=7;
    INTEGER FP61=8;
    INTEGER FP62=9;
    INTEGER FP84=11;
    INTEGER FP85=12;
    INTEGER FP86=13;
    INTEGER FP90=14;
    INTEGER FP91=15;
    INTEGER FP100=16;
    INTEGER FP_11=19;
    INTEGER FP_11_1=20;
    INTEGER FP_11_2=21;
    INTEGER FP_11_3=22;
    INTEGER FP_11_4=23;
    INTEGER FP_11_5=24;
    INTEGER FP_11_6=25;
    INTEGER FP_11_7=26;
    INTEGER FP_11_8=27;
    INTEGER UNKNOWN=127;
    INTEGER UNSPECIFIED=0;
    INTEGER QN132=1;
    INTEGER VQ100=2;
    INTEGER TQ144=3;
    INTEGER PQ208=4;
    INTEGER FG144=5;
    INTEGER FG256=6;
    INTEGER FG484=7;
    INTEGER FG676=8;
    INTEGER FG896=9;
    INTEGER QN108=10;
    INTEGER QN180=11;
    INTEGER TQ100=12;
    INTEGER CQ208=13;
    INTEGER FG1152=14;
    INTEGER BG456=15;
    INTEGER UNDEFINED=63;
    INTEGER GRADE_UNSPEC=0;
    INTEGER GRADE_1=1;
    INTEGER GRADE_2=2;
    INTEGER GRADE_3=3;
    INTEGER GRADE_F=4;
    INTEGER GRADE_STD=5;
    INTEGER GRADE_4=6;
    INTEGER GRADE_UNDEF=7;
ENDDATA;

DATA PARAMETERS;
    INTEGER FREQ =4;
ENDDATA;

DATA GV;
    INTEGER ULOPT1_BITLOCATION =23;
    INTEGER ULOPT0_BITLOCATION =22;
    INTEGER ULUWE_BITLOCATION =21;
    INTEGER ULARE_BITLOCATION =20;
    INTEGER ULUPC_BITLOCATION =19;
    INTEGER ULUFE_BITLOCATION =18;
    INTEGER ULUFP_BITLOCATION =17;
    INTEGER ULUFJ_BITLOCATION =16;
    INTEGER ULFLR_BITLOCATION =15;
    INTEGER ULULR_BITLOCATION =14;
    INTEGER ULAWE_BITLOCATION =13;
    INTEGER ULARD_BITLOCATION =12;
    INTEGER ULNR0_BITLOCATION =0;
    INTEGER ULNW0_BITLOCATION =1;
    INTEGER ULNC0_BITLOCATION =2;
    INTEGER ULNR1_BITLOCATION =3;
    INTEGER ULNW1_BITLOCATION =4;
    INTEGER ULNC1_BITLOCATION =5;
    INTEGER ULNC3_BITLOCATION =11;
    BOOLEAN BUFF128[128];
    BOOLEAN BUFF32[32];
    BOOLEAN VAR[128] = $01010101010101010101010101010101;
    INTEGER I;
    INTEGER J;
    INTEGER TEMP;
    INTEGER SDNUMBER;
    INTEGER ROWNUMBER;
    INTEGER DATAINDEX =0;
    INTEGER FROMROWNUMBER =1;
    INTEGER AESBLOCK;
    BOOLEAN ID[32];
    BOOLEAN PASS = 1;
    BOOLEAN FADDR[3];
    INTEGER STATUS =0;
    BOOLEAN SILSIG[32] = $00000000;
    BOOLEAN ISC_CONFIG_RESULT[18];
    BOOLEAN VERIFYEOL[2];
    BOOLEAN COMBERASESELECT[23];
    BOOLEAN SECKEY_OK = 1;
    BOOLEAN SECREG[56];
    BOOLEAN SULARD = 0;
    BOOLEAN SULAWE = 0;
    BOOLEAN SULULR = 0;
    BOOLEAN SULFLR = 0;
    BOOLEAN SULUFJ = 0;
    BOOLEAN SULUFP = 0;
    BOOLEAN SULUFE = 0;
    BOOLEAN SULUPC = 0;
    BOOLEAN SULARE = 0;
    BOOLEAN SULUWE = 0;
    BOOLEAN SULOPT[2];
    BOOLEAN SULNR0 = 0;
    BOOLEAN SULNW0 = 0;
    BOOLEAN SULNC0 = 0;
    BOOLEAN SULNR1 = 0;
    BOOLEAN SULNW1 = 0;
    BOOLEAN SULNC1 = 0;
    BOOLEAN SULNR2 = 0;
    BOOLEAN SULNW2 = 0;
    BOOLEAN SULNC2 = 0;
    BOOLEAN SULNR3 = 0;
    BOOLEAN SULNW3 = 0;
    BOOLEAN SULNC3 = 0;
    BOOLEAN ULUWE = 0;
    BOOLEAN ULARE = 0;
    BOOLEAN ULUPC = 0;
    BOOLEAN ULUFE = 0;
    BOOLEAN ULUFP = 0;
    BOOLEAN ULUFJ = 0;
    BOOLEAN ULFLR = 0;
    BOOLEAN ULULR = 0;
    BOOLEAN ULAWE = 0;
    BOOLEAN ULARD = 0;
    BOOLEAN ULOPT[2];
    BOOLEAN ULNR0 = 0;
    BOOLEAN ULNW0 = 0;
    BOOLEAN ULNC0 = 0;
    BOOLEAN ULNR1 = 0;
    BOOLEAN ULNW1 = 0;
    BOOLEAN ULNC1 = 0;
    BOOLEAN ULNC3 = 0;
    BOOLEAN SUROWCHECKSUM[16];
    INTEGER SUROWCYCLECOUNT =0;
    INTEGER ACT_UROW_CYCLE_COUNT =0;
    BOOLEAN ACT_UROW_DESIGN_NAME[70] = $1afb365e1f3a7f6cfb;
    BOOLEAN SUROWDESIGNNAME[70];
    BOOLEAN SUROWPROGMETHOD[3];
    BOOLEAN ACT_UROW_ALGO_VERSION[7] = $14;
    BOOLEAN SUROWALGOVERSION[7];
    BOOLEAN SUROW_PKG_TYPE[6];
    BOOLEAN ACT_UROW_SW_VERSION[7];
    BOOLEAN SUROW_SW_VERSION[7];
    INTEGER PLAYERVERSIONVARIABLE =0;
    INTEGER PLAYERVERSIONSWVARIABLE =0;
    INTEGER SCULPTORMAJORBASE =5;
    INTEGER SCULPTORMINORBASE =16;
    BOOLEAN ACT_UROW_PROGRAM_SW[4];
    BOOLEAN SUROWPROGRAMSW[4];
    BOOLEAN SUROW_SPEED_GRADE[3];
    BOOLEAN SUROW_SRAM_DISTURB[1];
    BOOLEAN ISERASEONLY = 0;
    BOOLEAN ISRESTOREDESIGN = 0;
    BOOLEAN FLAGDISPLAYCYC = 1;
    BOOLEAN ISPRGARRAY = 0;
    BOOLEAN BSRPATTERN[885] = $1249249249249249249249249249249249249249249249249
        249249249249249249249249249249249249249249249249249249249249249249249249
        24924924924924ffc9249249249249249249249249249249249249249249249249249249
        24924924924924924924924924924;
    BOOLEAN SAMPLEMASK[885] = $0000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        00000000000000000000000000000;
    BOOLEAN BSR[885];
    BOOLEAN SAMPLE_DEVICE[885];
    INTEGER BSROINDEX =0;
    INTEGER OINDICES[50] = 561,558,555,552,549,546,489,486,483,480,471,468,459,456
        ,453,450,735,732,729,726,717,714,705,702,693,690,681,678,669,666,657,654
        ,645,642,633,630,621,618,615,612,
    609,606,597,594,591,588,585,582,579,576;
    BOOLEAN RLOCK[832] = $7fffffcffffffbfffffeffffffbfffffefffffffffffffffffff3f
        ffffcffffff3fffffcffffff3fffffcffffff3fffffdffffff3fffffcffffff3fffffcff
        ffff3fffffcffffff3fffffdffffffffffffffffffffffffffffffffffffffffffffffff
        ffffffffff;
    BOOLEAN ARRAYRONLY = 1;
    BOOLEAN CHKARRAY = 0;
    BOOLEAN FROMRONLY = 1;
    BOOLEAN CHKFROM = 0;
    BOOLEAN CHKNVM = 0;
    BOOLEAN CHKSEC = 1;
    BOOLEAN PERMLOCK = 0;
    BOOLEAN NVM0RONLY = 1;
    INTEGER HEX[16] = 70,69,68,67,66,65,57,56,55,54,53,52,51,50,49,48;
    INTEGER NVMPOLL =0;
    INTEGER NUMBEROFFROMROWS =8;
    BOOLEAN INITIALIZE_DATA[5] = $00;
    INTEGER SDTILE;
    INTEGER NUMBEROFSDTILES =4;
    INTEGER NUMBEROFMAPROWS =1772;
    INTEGER IDREV;
    INTEGER IDFAB;
    INTEGER BM7DEVICE =0;
    INTEGER BM1DEVICE =0;
    BOOLEAN M1BUFF[128] = $acdd6548ccb488863e291eb18fe95077;
    BOOLEAN M7BUFF[128] = $e137623a2eeee91126015f3f73664945;
    BOOLEAN IDCODEVALUE[32] = $05a131cf;
    BOOLEAN IDMASK[32] = $0dffffff;
    INTEGER SECKEYCHK =0;
    INTEGER DESIGNPKGTYPE =7;
    BOOLEAN ACT_UROW_PROG_METHOD[3] = $1;
    INTEGER LABEL_SEPARATOR =0;
    INTEGER ROWITERATION =100;
    INTEGER PAGEITERATION =100;
    INTEGER PERCENT_UPDATE;
    INTEGER DIFFERENCE;
    INTEGER UNIQUEEXITCODE =0;
ENDDATA;

DATA BITSTREAM;
    BOOLEAN UROW[128];
    BOOLEAN UROW_MASK[128] = $fffffffffffffffffffffffffe01ffc0;
    BOOLEAN DATASTREAM[1474304] = @W@i00000110040W0W000020G000400108002200000Wwc
        qssso0000p@@lF999IjjjQp0000_@x@@IYaatcjj50000y_@@7HIIIORRRR36uXaa49jjTDq
        WD2000y@@EH0vssMj90008@@z@69HIo000049IIICIII2Va00008III0HII2i134999H899f
        67Waaa4aaaKD020Za491aa8900gX7GIIIA0000800m0G0aaaa9mWauWku00000IIIIg1Vqss
        sosssc3999A1000jjjQpjjPRMIYay0000tcjjbMjjj8III20000ORRR3RRRhWaaa3ZWQW3sO
        RRssba897000mskJAGIIIYC000Wbaa8vIIaaJRpsEJYaaD9IIo4999sijjz8999B999fKHWj
        jj19999aaaaGIII2QRRpIIIY4IIoQm6caaausssgZaa4PIIIdW0PRRRsIIIa600So88EH0II
        IYxa1r72IF6WaaaySHGDW50IIIr07AK6KV8O0OGDuWIQ1r02AY4K3QeTDHDu22000r05w4Ae
        ssscJIIIUy0ejjj2aaa84000G00e6GGhK1ijjjYaaa2d7K3w0JIIIkyWQW2qsssWjjjvIIIY
        O@@l@jjDR7RRssaa89X@x@Vsk6KW99992@@@_nssiDjjT@80n@@VD84LIII4@@@zjjjPpQRh
        JW04@@@_GRRrMRRpsijLRxlDRRtMjjTtijjNrss6pssssssscsssMHRRRMQRRrYjjPRijLRp
        sMD01sORRh1ymssscvssMjRRRsCRRrsljL3GWz000040030OK3uK@Z130Br9SX000WQ0D2De
        fjmf1WCZJMB22jOho2q_FGp@1Q_FGp@1Q_FGp@1Q_FG3l8999HIII2baa41999oIIIaeaa89
        89HIMIYa49f6G10999HGIIc1W089992IIIaaaa81IIg6W7T2ce6W6H3UAGZ@3qu@0D_FG3Nh
        4q0GIIIa200YKW04000W899BpyWS3LOKH3QFyWQ00fJ0AsHyW10I02000800W10sfJ0Aaaaa
        O0000GIIYS0000A99I20000ca89H0e6W2400008999N12g1mWqEFe6WEw4OYI6Fmaaa45000
        WIIIz7GWIIII0000W899xHWaQ0eeJWB21m0Waaae000g2W020000IIIa100q7m1jIGGY09SO
        m1r0CId0KaB91f1K0WIIoq080HIIID0Gq9G4r0CId0EC0m@30yV0Dr5DmQ1ezVWJ@7uq@12_
        Vy8a7Qm@1qyVm9@7K7GA999ZZx2baaazmTHD0T4yew1dyVm9@7yur1DWMmZ@7yu@1F_@00@7
        Gp@1F_VmZ@7yu@1F_VOO@7Qm@1qyVmZ@7yu@1F_Vm9@7yu@1F6lijjD3000Wsssi50000QRp
        s6000WiDRR70r0W0WjjDR000r0GmDX4ejjjf6WHw482ssssGIIIaRRRp899H2jjDRXa49fss
        ijJIaa4sM3G1Yjjjh1G1YjjjQaaag18aE1emssscJIIIGRRRs999Hgjjz4m1CJIIaussgjII
        g602iGIIY4RRxMW5g1eZE1ce6020000uaaa42000GIIIa2009HU0eaa49200@CUmvX70999f
        FI5g1GZE1iG2@@l@Xa499@@_@JIaa4@x@@DHII2l@@@79999r0aW799fQ0809999u@@VFaaa
        r0GId0DuZaayZ02KRRR@uW1tFG0sssM5000WQRRrA00K3W23FG0sssss28msssID0cq9G3r0
        Gm00@F0m@1RzVmZ@7yu@1ezVmZ@76s@1ezVmZ@7So@1F_VmZ@7So@1F_VmZ@7yu@1F_@00@7
        yu@1RzVmZ@7yu@1ezVm9@76s@1ezVmZ@7yu@1F_VmZ@7So@1F_VmZ@7yu@1F_@00@7yu@1Rz
        VmZ@7yu@1F_Vm9@76s@1qyVmZ@7yu@1F_VmZ@7So@1F_VmZ@7yu@1F_@00@7Ws@1RzVmZ@7y
        u@1F_Vm9@76s@1qyVmZ@7yu@1F_Vm9@7So@1F_VmZ@7yu@1F_@00@7Ws@1RzVmZ@7yu@1F_V
        m9@7yu@1qyVmZ@7yu@1F_Vm9@7So@1F_VmZ@7yu@1F_@00@7Ws@1F_VmZ@7yu@1F_Vm9@7Qm
        @1qyVmZ@7yu@1F_Vm9@7yu@1F_VmZ@7yu@1F_@00@7Ws@1F_VmZ@7yu@1F_Vm9@7Qm@1qyVm
        Z@7yu@1F_Vm9@7yu@1F_VmZ@7yu@1F_@00@7Ws@1F_VmZ@7yu@1F_VmZ@7Qm@1qyVmZ@7yu@
        1F_Vm9@7yu@1F_VmZ@7yu@1F_@00@7Ws@1F_VmZ@7yu@1F_VOO@7Qm@1qyVmZ@7yu@1F_Vm9
        @7yu@1F_@00FORRRp1000ejjji6FW200mBV74yOKDEIJmZneaaa4ssscLIIIaRRRsE99HIjj
        5yOMO0000JIIYS00eaH2q0000899Ho00GmZFHIIIYz@@V9Z7Waaa4_@@lNIIIaz@@1FYrZ34
        mjjjjW022UytYLGhiCr3ev@W7@Fun@3Uy@W7@Fuaqxv1w0Q_Fun@3Uy@W7BEua@3Ev@W7@Fe
        1WQSKdQ0keBo9OZjj5yuJKIIIkMq09rssr0iGmZHL3W1M9993UaWE1C8un3KIIIMoe11FUW2
        0000999I4002U4dk8dGI@@VMZKubaainHIg1WYk8JWK@@l@B99Io@@r0G0o00WW7h2ejjDR1
        0WE1K8untwYy@k8@FeX@ZyAoW6_BunfZJmsWJ_Fua@3Qu@W7@Fu4y3UqwWWQU0W@3EnpW7jE
        eXo2Uq9RRRR1FE1xijjW7V2IIIImZ6K3W31FgLd0A4yum_baa8z@@7yeOT20HmZ@7Gp@1DyV
        mZ@7yu@1ezVmZ@7So@1DyVmZ@7So@1F_VmZ@7So@1F_VmZ0211810000W4WWwD8W4aW00000
        02IG4000g10AIG20020W8O110030W4yW0003002QG4001g1ufy9J0qsscj00WY99W10008RR
        Rs100LMkJd0HKCv4KRRRr9995M9IT2SWjjjDdaaaWsssiJIIYKRRx9W32hSdE1c8io3SIII6
        Mf18500AcaWI698ioUw4O29y@@vJUWF99fy99W9999u@@V@aaaXLYJd0JuZaayZ02AcCXx78
        0RRRh200WmA9gJW62hit10_l0dGx4GZe1GBiIeB_ofW6_BiofZJ0j88GBua@Z79qG3_FWc@3
        Ev@mA@FiIAYX1wWJ_FuaD3hqwW6ABun@3Uy@W7@V0W@3ev@W7@Fun@3Uy@W7@FCi@3Du@0Q_
        Fun@3Uy@W7@Fua@3Uy@W7@Fun@3Uy@W7@V0W@3ev@W7@Fun@3Uy@W7@FCi@3Du@0Q_Fun@3U
        y@W7@Fua@3Uy@W7@Fun@3Uy@W7@V0W@3ev@W7@Fun@3Uy@W7@FCi@3Du@0Q_Fun@3Uy@W7@F
        ua@3Uy@W7@Fun@3Uy@W7@V0W@3ev@W7@Fun@3Uy@W7@FCi@3Du@0Q_Fua@3Uy@W7@Fua@3Uy
        @W7@Fun@3Uy@W7@V0W@3ev@W7@Fun@3Uy@W7@FCi@3Du@0Q_Fua@3Uy@W7@Fua@3Uy@W7@Fu
        n@3Uy@W7@V0W@3ev@W7@Fun@3Gx@W7@FCi@3Du@W7@Fua@3Uy@W7@Fua@3Uy@W7@Fun@3Uy@
        W7@V0W@3sw@W7@Fun@3Gx@W7@FCi@3Du@W7@Fua@3Uy@W7@Fua@3Uy@W7@Fun@3Uy@W7@V0W
        @3sw@W7@Fun@3Gx@W7@FCi@3Du@W7@Fua@3Uy@W7@Fua@3Uy@W7@Fun@3Uy@10_V0W@3sw@W
        7@Fun@3Gx@W7@FCi@3Gx@W7@Fua@3Uy@W7@Fua@3Uy@W7@Fun@3Uy@10_V0W@3sw@W7@Fun@
        3Gx@WJ_FCi@3Gx@W7@Fun@3Uy@W7@Fua@3Uy@W7@Fun@3Uy@10_Fun@3sw@W7@Fun@3Gx@WJ
        _FCi@3ev@W7@Fun@3Uy@W7@Fua@3Uy@W7@Fun@3Uy@10_F0j@3sw@W7@Fun@3Uy@WJ_FCi@3
        ev@W7@Fun@3Uy@WJ_Fua@3Uy@W7@Fun@3Uy@10_F0j@3sw@W7@Fun@3Uy@WJ_Fun@3ev@W7@
        Fun@3Uy@WJ_Fua@3Uy@W7@Fun@3Uy@10_F0j@3Uy@W7@Fun@3Uy@WJ_FqW@3ev@W7@Fun@3U
        y@WJ_Fun@3Uy@W7@Fun@3Uy@10_F0j@3Uy@W7@Fun@3Uy@WJ_FqW@3ev@W7@Fun@3Uy@WJ_F
        un@3Uy@W7@Fun@3Uy@10_F0j@3Uy@W7@Fun@3Uy@W7@FqW@3ev@W7@Fun@3Uy@WJ_Fun@3Uy
        @W7@Fun@3Uy@10_F0j@3Uy@W7@Fun@3Uy@W7@FqW@3ev@W7@Fun@3Uy@WJ_Fun@3Uy@W7@Fu
        n@3Uy@10_Fun@3Uy@W7@Fun@3Uy@mm_FqW@3ev@W7@Fun@3Uy@WJ_Fun@3Uy@W7@Fun@3Uy@
        10_Fun@3Uy@W7@Fun@3Uy@mm_FqW@3ev@W7@Fun@3Uy@WJ_Fun@3Uy@W7@Fun@3Uy@10_FWc
        @3Uy@W7@Fun@3Uy@mm_FqW@3ev@W7@Fun@3Uy@WJ_Fun@3Uy@W7@Fun@3Uy@10_FWc@3Uy@W
        7@Fun@3Uy@mm_FqW@3ev@W7@Fun@3Uy@WJ_Fun@3Uy@W7@Fun@3Uy@10_FWc@3Uy@W7@Fun@
        3Uy@mm_FqW@3ev@WJ_Fun@3Uy@WJ_Fun@3Uy@W7@Fun@3Uy@10_FWc@3Uy@W7@Fun@3Uy@mm
        _FqW@3ev@WJ_Fun@3Uy@WJ_Fun@3UCN1000C000m0000I000G10m60403000S000W10W10gX
        00007000O00003000a000W40O3W2099990000eaa4100Wj680000m8240000Waaaa0000GII
        Ir0qYa30WQ0KW400GD04yF01H3WMS2e9000m100Gq0N4f2D60002Qu20000n9SHi26K3GBI6
        00YJeY10I0W00GA57010000000W00WW0aO@dEkJWX10KeJ032DW0bjjjQaaa8mssg5IIYaOR
        hs699IIijQRJ9HIIjPRRZ4999KD05G2ijLRZWKD04O399f6W6I3GXQ0EGdaa4fsssq0EG899
        9WjjDB800b3G0A000W100dCSmQ7_G00001000G00003000C006VW04000WG000G30Kr01W70
        0Y6W05000O0000400411E2000e00006000u00Gq04u10001000u00W0d_Fek@3Uy@W7@FGZ@
        3qu@0D_FGZ@3qu@0D_FGZ@34aw0D_FGZ@3qu@0DI5WW00020e84DW00040020G002b6MGD0D
        1;
    INTEGER CHECKSUM =29222;
ENDDATA;

DATA NVM_V;
    BOOLEAN NVMACCESS[5];
    BOOLEAN NVMBUSY[5];
    BOOLEAN NVMMASK[5];
    INTEGER PAGEADDRESS =0;
    INTEGER MAXATTEMPTNVMACCESS =100;
    BOOLEAN NVMADDRESS[35];
    BOOLEAN PROTECTION[5];
    BOOLEAN AESINIT[128];
    BOOLEAN NVMCAPTURE[35];
    INTEGER NVMACTIVEARRAY =0;
    INTEGER PARSIZE =0;
    INTEGER PAR =0;
    INTEGER PARWORDCOUNT =0;
    INTEGER OFFSET =0;
    INTEGER NVMDATAINDEX =0;
    INTEGER NVMPROTINDEX =0;
    INTEGER NVMWORDS =0;
    INTEGER NVMPAGES =0;
    INTEGER NVMWORDCOUNT =0;
    INTEGER NUMOFPARTPRIV_ALL =4;
    BOOLEAN NVMPARSIZEPRIV_ALL[128] = $00000080000000200000004000000580;
    INTEGER NVMDATASTREAMSIZEPRIV_ALL =52224;
    BOOLEAN NVMADDRPRIV_ALL[88] = $1ff0007fb0020f80081100;
    BOOLEAN NVMDATAPRIV_ALL[52224] = @0c100002008vW140h8OW0O_w240MJO01mY2680cgm0
        1W5qGeY9X412W1G4G0O3Y040BBOW0Ow234060000023680com01WPc14OA0LB0mxSz@6_8LW
        0GB8mJG020iWZe013MWIB8uHG01Ailn7C5yDyXf29WNoC80quql11_02GI8a4020C1qBWg50
        uz6_V3VAAGWe54u58012stmdWAa0U9oW1eEK48W020OVZF_98WCSW0w5Uq_D_WdWlXFyKuRy
        X79IWdbnR0m3u0qO81K70YGWx_6_WJ3ECg1uLyy2g02iUH5eIy91O60dAnl4GLGSje0LGmwj
        W0i0c1ahIyr2K5OEhGmpurd3EwNF1F0O8WIy4y1W10AnF7OaV3u451l0A0WJCmw6o03M7J6u
        hCi4V42c1eh0x41_1OB0n78G5H4K0IWAY8e0e0L4HG1O1Afm10o360W0D6e2Td6Uy2tHWeM2
        OK4n20uNn_06hlnd8400QW6VI10mCmXVJYz01adeNVnXqG8K8UyB0R00uxn_GqB000ErI9i8
        m80Ww3oZaWOJoi1i7ad511a800U6jF0WW0uVm00agkuYOp7W4Y20ly11k0dVJ276q2um_ReN
        0y883KeZILXD0_6_GF29mF4W8yy2IWlXFppOWr3I41iE1380o3P0085l0DO6WfVH2Y8Wei0@
        RuJw8LX38ntu3qP6eAa0G38Td@D_WSalXFXpOWr3q0RXdjFu8@Amw2EW08FiHGWr3K018F0Z
        uQdljImUf1iUW3OJysE8a0QZGWWG1mCYZTE1fAAy714Hla1MN0I8mwj020U4ywybNo0h7e0M
        6F30F168Py40y88W1YL0Z4WO3847tK1LX2Ci02q5A0KHKgp9690Wu00FC3WqlFXU0025m2dU
        R9Tm@KZD92820Zevq9m8DdE36fPfZm8QET5C20f00uTIWAQ4GGC85KGr00_@0m@thg@DWHN0
        E0B0GDy4z08E49a3Rx9w1IS8Aa3s60mF0088r0iEm00wq1mP60ELHo0e90uIDfeWF8W1WJ20
        8042Hn30mdl_0oZm4F0106Wo1GDdE020qSn2EvV3o5dOIaC0Q20E9JAgSH1e4V30O0W0WG4Y
        H00lar7eWH1C0e704uu1ZO50AC1D2ccIW3ZHoneYOqaWZIy50a8N4EaM0Y8m8mD_8y0A@Y0H
        mLyXy0K_LISaRyXW2CIkn728mcS03Zon8fkE2AOTD8D600UErd16z0Z_0S1NK7zX2w27GaSZ
        lFmWEX3C2knt7OWkJ701WwwIeWrx3AGVwtiq1805P400l9Zg180WPadWO2SWY72M7W2q8_80
        mPD2W6rjq18Ie6V008WG48G1Gz42GCw30xJ0wQ34mb_0n30LN200Wu381TYF2008FY2Cm214
        3z1uUA0T001WGq9_8040WtHw34F0KTB000YFW5abH8n80W7KwV9rDu1K0j1Cw1ZY2GWG410u
        bH@k4307Gv18WuGGn3W040S0K20090ZOUUkIeFaEwW0Hu2A_b0H4YBeuN9vG4jWYV9O4Xq2A
        _TJEqw6hNRK0KqlWMX38ZH00_4qlKm0e0KE0Y0mLhGyuNvs00mxly51HIMWaQ8WHCBGRnZde
        70rfAXIGQYqKLmN4eKYw3O0C6o7954y510H0_Je7ewegG6GQDKY4effXWO8Oa420p0m90y3G
        02Mr0hBC14ET0402eHtu5W2@X_PTL3msBqX@HDW40G3QyXA01f10600B04u168JQEaeG0Wm0
        020e1z02WH004084GX00Y0180G0o3403C0W0mW00806hW01mm2080C8eW0010C40860G04O0
        04W03W028017OW200W10J40000010000CGCm3c09AaKeh3W00Ly10WMNF028Qy8G014V02W0
        Q5Ly18WdKFA1C0Yc0G04l00GWu5W0X6l0200fKVqG094a40zAWH60O10UAW1sFQuS40@200g
        Y380coS01WnO00I8D9000ebqXtH22hdW70AG7I00D0090mZHy1aHon4gn70G_4z00CG06kn3
        W7Gml00FpolDDXYH00UQeF0mZAzNZJiz4Oq3VZPD_A00SGcruB10m3PMZly00Kn3CGCB949a
        3It1G00G3NWXkV0A1hXVUGKBIWF28Ag344m3i10Ew_1FmGLQu26Kz3Op304m1CKe6_W1zqmJ
        OmW7S23EuXlPW5FS5cjuR00eII806Ou3Fd1@UmzCRXV300@p00yneFSMx99X0Gi6@_0XJA92
        WGmGuCc@l7Gy@@zibV00@Twx@xnm@MZl_00O3u0rmPDGGFWm0dni6_z1006m0L30yE2V1P4E
        h18w108uCcWC2A6z@z4aVVWKme9v38olzaa00ZOu30ar248P14GrwaaW0pVdtBwc@800F3x2
        0GkHI9Wc42819OZIIKZ30TDA9HD80qraa4GBH7Wql204uSqB810q00ym5402009qYI0K330z
        JqBH90a670DMK2GQSGqYDUGz4W11u7WpHn6FW_AVd308fq4m4a00Q4D0oM04610y40VGO44z
        2gQ5HIEW6HII1e94y0IA50M8CH0Z0m8YkF320890aw26iaaG7A10ulc_0n1m030W0AO204G0
        68e1u1uNr002G03CW1AOWgN00WGH01mGGx00ECz01Wjh7G0C0021W301H00S2220700a@@_@
        V3003W10W4YtLmAzhoDC1Z0G0id5Je506dzY2S022076ksa2uv3406hU01mm1840E8070W3a
        GU00Cv12WHfPNq170Dfy82u7mE00@0iJ8GRn3kNq3U0FY62wSmqWXsOXEEG02T05wu0Xyb66
        yEr18vtOXE2G0KqH044zhemd0x04_8O7fT09@A6y5mAWWF1MX8@k0U60EuS42wuWfZ5w8014
        q1ec06OvxbsK7GkpbMMWeZ8_50z9Gy004uEYK21jWaEUW8Ga0A8W0DGG2eW02S7nFJOeMWkV
        0693Z0XHCeNfbDC012HV10F0X0kZ0XCH74e129059GY68a04S75Vf01H8i00aMXF000MHiHI
        zYF0000mph_X08mC8L0qAGUeIGlm7004UY8I8C_50mNCz10aS0403HQ9Bm1CL@MXF00a1W0X
        c8Y91Amiw3GIW206Qbmf0QWo003W02U07KlT1AmZwtQ4W2qF_0o80E9L31U0w0eg0f27Z00y
        vZl0qK0PsB_118mUwtAy100@nnHAwzfB1GWmI4nS15eGz18NG1g6VK1G0DGH0W9Nm22J@Mh8
        SWGI4nk05mDz9er4124WVpQGGI92IBHW@@@10GIIKeD3WsHe1QyH0WGZF6WK4m@d042Ub8W2
        bH4uXZOAK6HetV284zeK0521K0XW7AYfGPmW91eE12u4r9m02fk14G1b5C_e2GAmaHgZW1M6
        PZeU30281JDgjIK715a0r9O05f_0Aenou0JDfjAW70FD0eRkDL0V0UOVe36OW4OI4gJW062D
        Xg4KWUH7U30tHnKA007z0W0280y@VldA0W00WZ0e5f3@0Q897eaehB012Ly14WMNN03CQy8O
        W14V0301Q7Ly1CWdKNA2m0Yu0m04l01OWu5m0Y6l0400gKVq0etq812WfY9G0OBW40GR199G
        Q6oU@Dd60H9n4GQ2FF15I9W9GQ4U_X8b2W1eq8Z8mkFvX79X1tHp388B1181420Eyq20GYGI
        J92Wa@VpKK20TzYGn3En6qCmw5M02YN160YBuvtsiM9wZ0wFmqkk6YZ747uBGX0C0D3n1W22
        V4ia2WHAF8UqmZNuE20@2WG80yO14u7a00QGZFM100D0tHWXsUiqECX4qe6_i24E0Y8m3CHe
        2VO051h3O002Qh0aXW7O3j0OIfX20@0302u70020D1Gf0GRWqmY3aC44W16UXpHOrXyF76y2
        0yoBNSKRA85Bm04qW2W_aaW0G01UWBIrf3W000U4WF2gXCFWVqneNSgL1D02b40821Fm8IH4
        8901KBu040T0G11eD0AC0QM0NA612Z20MzYEC0g5mp0eWj0VNnAmA20w5Cz6W3WMs0qWW60H
        0G046Q20C4GJRUu_eZHl0q28WcAuJm242V2iGRU8@eZHl0qY3WcAuJm2W0isuX_HBcU10yba
        lOwbLGW0Ou@@700SrQZO5mAG0j3cM5WdriW0@0ip4m99FqNqmrhGc52u7mE40V2iJIU8@eXJ
        l2W69HGI0CG72Es9WV1BX2u0Wy5001HGI000y6WWAWcv0eUWa2_4y6n1GOn3Y0CGV18lA399
        FINqmrB0WlTu3NlH3S0CuBWTc0me18q1W0YWF1H3YmCuRWbe0G08l1H3EHku3dU7G9IW64GJ
        QyH0u0QU4G4S7XWs10SJ0F0OQWgjbGIHenY703m9r3X1L4z64AbebWGC9QLY5X61hzb7U2iF
        446kZ00yl3N_dEFB1Wxe5I0IWG00aMO4WCZ6mq994W4ACn3G0_@_mzFP0WWfJA4m18He1o5a
        08w5I25tw6W1mDDSrAMz34zpgl1hd5RCAG8EUGKWCwh0xdnGY2alW706PEG40yjWmNgJ618a
        6njk1AW4@2YHIn8x44zJJ00M00m00021Ez6WAoDRuKB5C04eZb_1IFPrNGrJSy0X0oa1jn34
        3isqo2alW704HFG0e410kK8uBrdn06hXuMN0EGolWneuO4P1fjWcFJG101WK00SzY1ZYr_o7
        F1sF25r21AIT8KKjxJUw5m_KK50b58gNGHgTVv3GG0f0IT404Sw50003jg9M4MYKU08P9G2a
        AR4mFWjm6Gp0VA02Xg30G0G5o7DWa56UpqK03G0CmGB6GA0q40zWBiBKI4350mUGUS1G5Iw9
        u1WK0O4AC2Z2jFfxWB4WV0sQBE0oAtRQ06Hzd33QN0fo06G1bYeCG1O2W4A3q16Q70WJ00ql
        00010WOgic282zade243zaJCAfZ02H1XgW0nGID4GCA89nKH82WMqIBjOgic2L5rqJ03WKGI
        X8GCIGLn4gQf5jqIB00kZ00058f4G30fK0a00Q8W6Wc714z4y043eWi8400W008@VFt@70e4
        0q0s8WP40Wu@xdn_00F0m7Gr20y40N0yB00u0Zmf7e2i@v00W0I26WiAVt@Sc0W000OZA0m0
        @Vlt_@@xv@l@x_4@D203I0mYGgGP0W@70u@10_V0W@70u@10kp002m00NGaYA20JUa014WUW
        802W400ebO44000GQ060m0Uen1E0W20040a00130GWLO5M2h06G1MXfmAi2MXL07m1i0EObA
        08O10d_Aa00WtdG0081zKK0m_760S_lv0eMnvXx84GDOB00yV0C0009004G0W1WW04G08090
        3040X0GW06022G41W0a900618W1016I0080003024zB0LmZ4CQ01AuY0OXOLWOA00020X2E9
        0c0W8P18X800W10YX800Wd00eX6AG200000e100mI0270e8000040260e4XC0GSuZ10Y3naG
        WSmh42272o01vmFC8474zX1nXdFO8E0000y3a0G005000004Z0u083W00200000GW010A202
        G1120830000WH8070C9482W2W1520e1000009A40eu080dK8G4050LA482W2oF0XiB9W2000
        08WYu0CO00usoaW40O04W10WqlAknq0yV202AW09u@a080480GVm@H4G0O80WErVp2W00000
        yl@p41G1ku@18G0m80Wkq@J0mE55C0mA;
    BOOLEAN NVMPROTECTPRIV_ALL[12] = $000;
    INTEGER NUMOFPART_ALL =0;
    BOOLEAN NVMPARSIZE_ALL[0];
    INTEGER NVMDATASTREAMSIZE_ALL =0;
    BOOLEAN NVMADDR_ALL[0];
    BOOLEAN NVMDATA_ALL[0];
    BOOLEAN NVMPROTECT_ALL[0];
ENDDATA;

DATA NVM_R;
    INTEGER NVMDATAIDX =0;
    INTEGER PAGES =0;
    INTEGER INVMSIZE =0;
    INTEGER INVMOFFSET =0;
    BOOLEAN NVMADDR[35];
    BOOLEAN NVMDATA[1024];
    INTEGER NVMPAGEADDRESS =0;
    INTEGER NVMCRC =0;
    INTEGER INVMSTART =0;
    INTEGER INVMEND =0;
    INTEGER BDISPIAPUROW =0;
ENDDATA;


PROCEDURE DO_EXIT USES GV;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $81;
    WAIT IDLE, 250 USEC;
    IRSCAN 8, $81, CAPTURE BUFF128[7..0];
    IF ( ! (BUFF128[2]==0) ) THEN GOTO Label_0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $07;
    WAIT IDLE, 1 CYCLES;
    WAIT IDLE, 200 USEC;
    Label_0:
    IRSCAN 8, $ff;
    WAIT IDLE, 200 USEC;
    WAIT RESET, 3 CYCLES;
    EXIT STATUS;
ENDPROC;

PROCEDURE DO_EXIT_ACCESS_NVM USES GV,NVM_V;
    NVMACCESS[4..0] = $00;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $b6;
    DRSCAN 5, NVMACCESS[];
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 2 USEC;
    EXIT STATUS;
ENDPROC;

PROCEDURE DO_READ_SECURITY USES GV;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $a4;
    WAIT IDLE, 3 CYCLES;
    DRSCAN 56, $00000000000000, CAPTURE SECREG[];
    ULNR0 = SECREG[ULNR0_BITLOCATION];
    ULNW0 = SECREG[ULNW0_BITLOCATION];
    ULNC0 = SECREG[ULNC0_BITLOCATION];
    ULNR1 = SECREG[ULNR1_BITLOCATION];
    ULNW1 = SECREG[ULNW1_BITLOCATION];
    ULNC1 = SECREG[ULNC1_BITLOCATION];
    ULNC3 = SECREG[ULNC3_BITLOCATION];
    ULUWE = SECREG[ULUWE_BITLOCATION];
    ULARE = SECREG[ULARE_BITLOCATION];
    ULUPC = SECREG[ULUPC_BITLOCATION];
    ULUFE = SECREG[ULUFE_BITLOCATION];
    ULUFP = SECREG[ULUFP_BITLOCATION];
    ULUFJ = SECREG[ULUFJ_BITLOCATION];
    ULFLR = SECREG[ULFLR_BITLOCATION];
    ULULR = SECREG[ULULR_BITLOCATION];
    ULAWE = SECREG[ULAWE_BITLOCATION];
    ULARD = SECREG[ULARD_BITLOCATION];
    ULOPT[1] = SECREG[ULOPT1_BITLOCATION];
    ULOPT[0] = SECREG[ULOPT0_BITLOCATION];
ENDPROC;

PROCEDURE DO_OUTPUT_SECURITY USES GV;
    PRINT "Security Settings :";
    IF ( ! (ULUFP==1) ) THEN GOTO Label_1;
    PRINT "FlashROM Write/Erase protected by pass key.";
    Label_1:
    IF ( ! (ULUFJ==1) ) THEN GOTO Label_2;
    PRINT "FlashROM Read protected by pass key.";
    Label_2:
    IF ( ! (ULAWE==1) ) THEN GOTO Label_3;
    PRINT "Array Write/Erase protected by pass key.";
    Label_3:
    IF ( ! (ULARD==1) ) THEN GOTO Label_4;
    PRINT "Array Verify protected by pass key.";
    Label_4:
    IF ( ! (ULNW0==1) ) THEN GOTO Label_5;
    PRINT "NVM block 0 Write protected by pass key.";
    Label_5:
    IF ( ! (ULNR0==1) ) THEN GOTO Label_6;
    PRINT "NVM block 0 Read protected by pass key.";
    Label_6:
    IF ( ! (ULUFE==1) ) THEN GOTO Label_7;
    PRINT "Encrypted FlashROM Programming Enabled.";
    Label_7:
    IF ( ! (ULARE==1) ) THEN GOTO Label_8;
    PRINT "Encrypted FPGA Array Programming Enabled.";
    Label_8:
    IF ( ! (ULNC0==1) ) THEN GOTO Label_9;
    PRINT "Encrypted NVM block 0 Programming Enabled.";
    Label_9:
    IF ( ! ( ( (ULULR==1)&&(ULFLR==1))&&(ULUPC==1)) ) THEN GOTO NO_PAGE_PROTECTION;
    PRINT "Device is secured with a user pass key. Any secured eNVM clients are protected by pass key.";
    NO_PAGE_PROTECTION:
    IF ( ! (ULNC3==1) ) THEN GOTO Label_10;
    PRINT "M3 debugging capability has been disabled and is protected by pass key. To enable M3 debugging
        , you must either change or remove security settings.";
    Label_10:
    PRINT "=========================================";
ENDPROC;

PROCEDURE DO_QUERY_SECURITY USES DO_READ_SECURITY,DO_OUTPUT_SECURITY;
    CALL DO_READ_SECURITY;
    CALL DO_OUTPUT_SECURITY;
ENDPROC;

PROCEDURE DISP_SF_USER_ADDR USES GV,NVM_V;
    IF ( ! (PAGEADDRESS<2048) ) THEN GOTO NOT_BLOCK_0_USER_PAGE;
    PRINT "User Page: ",PAGEADDRESS;
    NOT_BLOCK_0_USER_PAGE:
    IF ( ! ( (PAGEADDRESS>2047)&&(PAGEADDRESS<2112)) ) THEN GOTO NOT_BLOCK_0_SPARE;
    PRINT "Spare Page: ",(PAGEADDRESS-2048);
    NOT_BLOCK_0_SPARE:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE READ_NVM USES GV,NVM_R,DO_EXIT;
    NVMDATAIDX = 0;
    PAGES = ((INVMSIZE+1023)/1024);
    NVMPAGEADDRESS = INT(NVMADDR[34..21]);
    INVMOFFSET = INT(NVMADDR[19..15]);
    IF ( ! (PAGES>1) ) THEN GOTO VALID_SIZE;
    PRINT "Failed to read Embedded Flash Memory Block (EFMB).";
    UNIQUEEXITCODE = 32908;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    STATUS = -55;
    CALL DO_EXIT;
    VALID_SIZE:
    INTEGER IREPEAT_0;
    FOR IREPEAT_0 = PAGES - 1 TO 0 STEP -1;
        IRSCAN 8, $b8;
        DRSCAN 35, NVMADDR[];
        WAIT 3 CYCLES;
        WAIT 20 USEC, DRPAUSE;
        FOR NVMPOLL = 0 TO 10000;
            DRSCAN 35, NVMADDR[], CAPTURE BUFF128[34..0],COMPARE $000000000,$400000000
                ,PASS;
            IF ( ! (PASS==1) ) THEN GOTO Label_11;
            NVMPOLL = 10000;
            Label_11:
            IF ( ! (PASS!=1) ) THEN GOTO Label_12;
            IRSCAN 8, $b8;
            WAIT DRPAUSE, 100 USEC, DRPAUSE;
            Label_12:
            LABEL_SEPARATOR = 0;
        NEXT NVMPOLL;
        IF ( ! (PASS==1) ) THEN GOTO NVM_READ_ECC;
        IF ( ! ( (BUFF128[33]==1)&&(BUFF128[32]==0)) ) THEN GOTO NR_ECC;
        PRINT "ERROR: 2 or more errors found on page: ",NVMPAGEADDRESS,".";
        STATUS = -39;
        UNIQUEEXITCODE = 32905;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT;
        NR_ECC:
        IF ( ! (BUFF128[3]==1) ) THEN GOTO NR_WC;
        PRINT "WARNING: Write count threshold exceeded on page: ",NVMPAGEADDRESS
            ,".";
        NR_WC:
        LABEL_SEPARATOR = 0;
        NVM_READ_ECC:
        IF ( ! (PASS==0) ) THEN GOTO NR_CONTINUE;
        PRINT "Failed to read Embedded Flash Memory Block (EFMB).";
        STATUS = -55;
        UNIQUEEXITCODE = 32906;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT;
        NR_CONTINUE:
        FOR I = 1 TO (32-INVMOFFSET);
            IRSTOP IRPAUSE;
            DRSTOP DRPAUSE;
            IRSCAN 8, $b7;
            DRSCAN 35, $000000000;
            WAIT IDLE, 3 CYCLES;
            WAIT IDLE, 10 USEC;
            DRSCAN 35, $000000000, CAPTURE BUFF128[34..0];
            IF ( ! ( (BUFF128[34]==1)||(BUFF128[33]==1)) ) THEN GOTO Label_13;
            PRINT "Failed to read Embedded Flash Memory Block (EFMB)";
            EXPORT "buff128", BUFF128[34..0];
            STATUS = -55;
            UNIQUEEXITCODE = 32907;
            BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
            EXPORT "ERROR_CODE", BUFF128[15..0];
            CALL DO_EXIT;
            Label_13:
            NVMDATAIDX = (NVMDATAIDX+32);
            IF ( ! (NVMDATAIDX<=INVMSIZE) ) THEN GOTO Label_14;
            NVMDATA[(NVMDATAIDX-1)..(NVMDATAIDX-32)] = BUFF128[31..0];
            Label_14:
            LABEL_SEPARATOR = 0;
        NEXT I;
        NVMPAGEADDRESS = (NVMPAGEADDRESS+1);
        BUFF32[31..0] = BOOL(NVMPAGEADDRESS);
        NVMADDR[34..21] = BUFF32[13..0];
        INVMOFFSET = 0;
        NVMADDR[19..15] = $00;
    NEXT IREPEAT_0;
ENDPROC;

PROCEDURE GENERATE_NVM_CRC USES GV,NVM_R;
    INTEGER FEEDBACK =0;
    INTEGER IDATA =0;
    NVMCRC = 0;
    FOR I = INVMSTART TO INVMEND;
        IRSCAN 8, $ff;
        IF ( ! ((I%8)==0) ) THEN GOTO NOT_NEW_BYTE;
        IDATA = INT(NVMDATA[(I+7)..I]);
        NOT_NEW_BYTE:
        FEEDBACK = ((IDATA^NVMCRC)&1);
        NVMCRC = (NVMCRC/2);
        IF ( ! (FEEDBACK==1) ) THEN GOTO FEEDBACK_NOT_ONE;
        NVMCRC = (NVMCRC^INT($8408));
        FEEDBACK_NOT_ONE:
        IDATA = (IDATA/2);
    NEXT I;
ENDPROC;

PROCEDURE READ_IAP_UROW USES BITSTREAM,GV,NVM_R,READ_NVM,GENERATE_NVM_CRC;
    BDISPIAPUROW = 0;
    NVMADDR[34..0] = $107ad9000;
    INVMSIZE = 160;
    CALL READ_NVM;
    INVMSTART = 32;
    INVMEND = 159;
    CALL GENERATE_NVM_CRC;
    IF ( ! ( (NVMCRC!=0)&&(NVMCRC==INT(NVMDATA[31..16]))) ) THEN GOTO IAP_NOT_USED;
    BDISPIAPUROW = 1;
    UROW[127..0] = NVMDATA[159..32];
    IAP_NOT_USED:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE READ_UROW USES BITSTREAM,GV,NVM_R,READ_IAP_UROW;
    IF ( ! (BDISPIAPUROW==1) ) THEN GOTO SKIP_READ_IAP_UROW;
    CALL READ_IAP_UROW;
    SKIP_READ_IAP_UROW:
    IF ( ! (BDISPIAPUROW==0) ) THEN GOTO SKIP_READ_UROW;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $c0;
    WAIT IDLE, 1 CYCLES;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $a8;
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 165 USEC;
    DRSCAN 128, $00000000000000000000000000000000, CAPTURE UROW[];
    SKIP_READ_UROW:
    SUROWALGOVERSION[6..0] = $00;
    IF ( ! ( (UROW[5]==0)&&(UROW[0]==1)) ) THEN GOTO Label_15;
    SUROWALGOVERSION[5..4] = UROW[24..23];
    Label_15:
    IF ( ! ( (UROW[5]==1)&&(UROW[0]==0)) ) THEN GOTO Label_16;
    SUROWALGOVERSION[5..4] = UROW[24..23];
    SUROWALGOVERSION[6] = 1;
    Label_16:
    SUROWCHECKSUM[15..0] = UROW[127..112];
    SUROWCYCLECOUNT = INT(UROW[111..102]);
    SUROWDESIGNNAME[69..0] = UROW[101..32];
    SUROWPROGMETHOD[2..0] = UROW[31..29];
    SUROWALGOVERSION[3..0] = UROW[28..25];
    SUROW_PKG_TYPE[5..0] = UROW[22..17];
    SUROW_SW_VERSION[6..0] = UROW[16..10];
    SUROWPROGRAMSW[3..0] = UROW[9..6];
    SUROW_SRAM_DISTURB[0] = UROW[4];
    SUROW_SPEED_GRADE[2..0] = UROW[3..1];
    ACT_UROW_CYCLE_COUNT = SUROWCYCLECOUNT;
ENDPROC;

PROCEDURE FIX_INT_ARRAYS USES GV;
    IF ( ! (HEX[0]!=48) ) THEN GOTO Label_17;
    FOR I = 0 TO 7;
        TEMP = HEX[I];
        HEX[I] = HEX[(15-I)];
        HEX[(15-I)] = TEMP;
    NEXT I;
    Label_17:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DISP_CHKSUM_DESIGN USES GV,FIX_INT_ARRAYS;
    CALL FIX_INT_ARRAYS;
    IF ( ! (INT(SUROWCHECKSUM[15..0])==65535) ) THEN GOTO Label_18;
    PRINT "CHECKSUM: ";
    Label_18:
    IF ( ! (INT(SUROWCHECKSUM[15..0])!=65535) ) THEN GOTO Label_19;
    PRINT "CHECKSUM: ",CHR$(HEX[INT(SUROWCHECKSUM[15..12])]),CHR$(HEX[INT(SUROWCHECKSUM[11..8])])
        ,CHR$(HEX[INT(SUROWCHECKSUM[7..4])]),CHR$(HEX[INT(SUROWCHECKSUM[3..0])]);
    Label_19:
    IF ( ! ( ( (INT(SUROWDESIGNNAME[0..30])==2147483647)&&(INT(SUROWDESIGNNAME[31..61])==2147483647))&&(INT(SUROWDESIGNNAME[62..69])==255)) ) THEN GOTO Label_20;
    PRINT "Design Name: ";
    Label_20:
    IF ( ! ( ( (INT(SUROWDESIGNNAME[0..30])!=2147483647)||(INT(SUROWDESIGNNAME[31..61])!=2147483647))||(INT(SUROWDESIGNNAME[62..69])!=255)) ) THEN GOTO Label_21;
    PRINT "Design Name: ",CHR$(INT(SUROWDESIGNNAME[63..69])),CHR$(INT(SUROWDESIGNNAME[56..62]))
        ,CHR$(INT(SUROWDESIGNNAME[49..55])),CHR$(INT(SUROWDESIGNNAME[42..48])),CHR$(INT(SUROWDESIGNNAME[35..41]))
        ,CHR$(INT(SUROWDESIGNNAME[28..34])),CHR$(INT(SUROWDESIGNNAME[21..27])),CHR$(INT(SUROWDESIGNNAME[14..20]))
        ,CHR$(INT(SUROWDESIGNNAME[7..13])),CHR$(INT(SUROWDESIGNNAME[0..6]));
    Label_21:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DISPLAY_UROW USES BITSTREAM,CONSTBLOCK,GV,NVM_R,DISP_CHKSUM_DESIGN;
    IF ( ! (BDISPIAPUROW==1) ) THEN GOTO SKIP_IAP_DISP;
    PRINT "IAP USER ROW INFORMATION:";
    SKIP_IAP_DISP:
    EXPORT "USER_ROW", UROW[127..0];
    PRINT "User information: ";
    CALL DISP_CHKSUM_DESIGN;
    IF ( ! (FLAGDISPLAYCYC==1) ) THEN GOTO Label_22;
    PRINT "CYCLE COUNT: ",SUROWCYCLECOUNT;
    Label_22:
    INTEGER TMPINT =INT(SUROWPROGMETHOD[]);
    INTEGER TMPINT2 =0;
    INTEGER TMPINT3 =0;
    INTEGER TMPINT4 =0;
    INTEGER TMPINT5 =0;
    IF ( ! (TMPINT==IEEE1532) ) THEN GOTO Label_23;
    PRINT "Programming Method: IEEE1532";
    Label_23:
    IF ( ! (TMPINT==STAPL) ) THEN GOTO Label_24;
    PRINT "Programming Method: STAPL";
    Label_24:
    IF ( ! (TMPINT==DIRECTC) ) THEN GOTO Label_25;
    PRINT "Programming Method: DirectC";
    Label_25:
    IF ( ! (TMPINT==PDB) ) THEN GOTO Label_26;
    PRINT "Programming Method: PDB";
    Label_26:
    IF ( ! (TMPINT==SVF) ) THEN GOTO Label_27;
    PRINT "Programming Method: SVF";
    Label_27:
    IF ( ! (TMPINT==IAP) ) THEN GOTO NOT_IAP;
    PRINT "Progarmming Method: IAP";
    NOT_IAP:
    PRINT "Algorithm Version: ",INT(SUROWALGOVERSION[6..0]);
    TMPINT = INT(SUROW_SPEED_GRADE[]);
    IF ( ! (TMPINT==GRADE_UNSPEC) ) THEN GOTO Label_28;
    PRINT "Device Speed Grade: speed grade information not available from device";
    Label_28:
    IF ( ! (TMPINT==GRADE_1) ) THEN GOTO Label_29;
    PRINT "Device Speed Grade: -1";
    Label_29:
    IF ( ! (TMPINT==GRADE_2) ) THEN GOTO Label_30;
    PRINT "Device Speed Grade: -2";
    Label_30:
    IF ( ! (TMPINT==GRADE_3) ) THEN GOTO Label_31;
    PRINT "Device Speed Grade: -3";
    Label_31:
    IF ( ! (TMPINT==GRADE_F) ) THEN GOTO Label_32;
    PRINT "Device Speed Grade: -F";
    Label_32:
    IF ( ! (TMPINT==GRADE_STD) ) THEN GOTO Label_33;
    PRINT "Device Speed Grade: STD";
    Label_33:
    IF ( ! (TMPINT==GRADE_4) ) THEN GOTO Label_34;
    PRINT "Device Speed Grade: -4";
    Label_34:
    IF ( ! (TMPINT==GRADE_UNDEF) ) THEN GOTO Label_35;
    PRINT "Device Speed Grade: speed grade information not available from device";
    Label_35:
    TMPINT = INT(SUROWPROGRAMSW[]);
    IF ( ! (TMPINT==FP) ) THEN GOTO Label_36;
    PRINT "Programmer: FlashPro";
    Label_36:
    IF ( ! (TMPINT==FPLITE) ) THEN GOTO Label_37;
    PRINT "Programmer: FlashPro Lite";
    Label_37:
    IF ( ! (TMPINT==FP3) ) THEN GOTO Label_38;
    PRINT "Programmer: FlashPro3";
    Label_38:
    IF ( ! (TMPINT==FP4) ) THEN GOTO Label_39;
    PRINT "Programmer: FlashPro4";
    Label_39:
    IF ( ! (TMPINT==FP5) ) THEN GOTO Label_40;
    PRINT "Programmer: FlashPro5";
    Label_40:
    IF ( ! (TMPINT==SCULPTW) ) THEN GOTO Label_41;
    PRINT "Programmer: Sculptor WIN";
    Label_41:
    IF ( ! (TMPINT==BPW) ) THEN GOTO Label_42;
    PRINT "Programmer: BP Programmer";
    Label_42:
    IF ( ! (TMPINT==DIRECTCP) ) THEN GOTO Label_43;
    PRINT "Programmer: DirectC";
    Label_43:
    IF ( ! (TMPINT==STP) ) THEN GOTO Label_44;
    PRINT "Programmer: Actel JAM Player";
    Label_44:
    IF ( ! ( ( ( ( (TMPINT==FP)||(TMPINT==FPLITE))||(TMPINT==FP3))||(TMPINT==FP4))||(TMPINT==FP5)) ) THEN GOTO Label_60;
    TMPINT2 = INT(SUROW_SW_VERSION[]);
    IF ( ! (TMPINT2==FP33) ) THEN GOTO Label_45;
    PRINT "Software: FlashPro v3.3";
    Label_45:
    IF ( ! (TMPINT2==FP34) ) THEN GOTO Label_46;
    PRINT "Software: FlashPro v3.4";
    Label_46:
    IF ( ! (TMPINT2==FP40) ) THEN GOTO Label_47;
    PRINT "Software: FlashPro v4.0";
    Label_47:
    IF ( ! (TMPINT2==FP41) ) THEN GOTO Label_48;
    PRINT "Software: FlashPro v4.1";
    Label_48:
    IF ( ! (TMPINT2==FP42) ) THEN GOTO Label_49;
    PRINT "Software: FlashPro v4.2";
    Label_49:
    IF ( ! (TMPINT2==FP50) ) THEN GOTO Label_50;
    PRINT "Software: FlashPro v5.0";
    Label_50:
    IF ( ! (TMPINT2==FP51) ) THEN GOTO Label_51;
    PRINT "Software: FlashPro v5.1";
    Label_51:
    IF ( ! (TMPINT2==FP60) ) THEN GOTO Label_52;
    PRINT "Software: FlashPro v6.0";
    Label_52:
    IF ( ! (TMPINT2==FP61) ) THEN GOTO Label_53;
    PRINT "Software: FlashPro v6.1";
    Label_53:
    IF ( ! (TMPINT2==FP62) ) THEN GOTO Label_54;
    PRINT "Software: FlashPro v6.2";
    Label_54:
    IF ( ! (TMPINT2==FP84) ) THEN GOTO Label_55;
    PRINT "Software: FlashPro v8.4";
    Label_55:
    IF ( ! (TMPINT2==FP85) ) THEN GOTO Label_56;
    PRINT "Software: FlashPro v8.5";
    Label_56:
    IF ( ! (TMPINT2==FP86) ) THEN GOTO Label_57;
    PRINT "Software: FlashPro v8.6";
    Label_57:
    IF ( ! (TMPINT2==FP90) ) THEN GOTO Label_58;
    PRINT "Software: FlashPro v9.0";
    Label_58:
    IF ( ! (TMPINT2==FP91) ) THEN GOTO NOT_FP91;
    PRINT "Software: FlashPro v9.1";
    NOT_FP91:
    IF ( ! (TMPINT2==FP100) ) THEN GOTO NOT_FP100;
    PRINT "Software: FlashPro v10.0";
    NOT_FP100:
    IF ( ! (TMPINT2==FP_11) ) THEN GOTO NOT_FP_11;
    PRINT "Software: FlashPro v11.0";
    NOT_FP_11:
    IF ( ! (TMPINT2==FP_11_1) ) THEN GOTO NOT_FP_11_1;
    PRINT "Software: FlashPro v11.1";
    NOT_FP_11_1:
    IF ( ! (TMPINT2==FP_11_2) ) THEN GOTO NOT_FP_11_2;
    PRINT "Software: FlashPro v11.2";
    NOT_FP_11_2:
    IF ( ! (TMPINT2==FP_11_3) ) THEN GOTO NOT_FP_11_3;
    PRINT "Software: FlashPro v11.3";
    NOT_FP_11_3:
    IF ( ! (TMPINT2==FP_11_4) ) THEN GOTO NOT_FP_11_4;
    PRINT "Software: FlashPro v11.4";
    NOT_FP_11_4:
    IF ( ! (TMPINT2==FP_11_5) ) THEN GOTO NOT_FP_11_5;
    PRINT "Software: FlashPro v11.5";
    NOT_FP_11_5:
    IF ( ! (TMPINT2==FP_11_6) ) THEN GOTO NOT_FP_11_6;
    PRINT "Software: FlashPro v11.6";
    NOT_FP_11_6:
    IF ( ! (TMPINT2==FP_11_7) ) THEN GOTO NOT_FP_11_7;
    PRINT "Software: FlashPro v11.7";
    NOT_FP_11_7:
    IF ( ! (TMPINT2==FP_11_8) ) THEN GOTO NOT_FP_11_8;
    PRINT "Software: FlashPro v11.8";
    NOT_FP_11_8:
    IF ( ! (TMPINT2==UNKNOWN) ) THEN GOTO Label_59;
    PRINT "Software: FlashPro vX.X";
    Label_59:
    LABEL_SEPARATOR = 0;
    Label_60:
    IF ( ! ( (TMPINT==SCULPTW)||(TMPINT==BPW)) ) THEN GOTO Label_64;
    TMPINT3 = (INT(SUROW_SW_VERSION[6..5])+SCULPTORMAJORBASE);
    TMPINT4 = (INT(SUROW_SW_VERSION[4..1])+SCULPTORMINORBASE);
    TMPINT5 = 0;
    IF ( ! (SUROW_SW_VERSION[0]==1) ) THEN GOTO Label_61;
    TMPINT5 = 1;
    Label_61:
    INTEGER CURRPGM =INT(ACT_UROW_PROGRAM_SW[3..0]);
    IF ( ! (TMPINT==SCULPTW) ) THEN GOTO Label_62;
    IF ( ! ( ( (CURRPGM==FP3)||(CURRPGM==FP4))||(CURRPGM==FP5)) ) THEN GOTO NOT_FP3_FP4;
    PRINT "NOTE: The Sculptor Windows version number below should be converted to HEX.";
    NOT_FP3_FP4:
    PRINT "Software: Sculptor Win v",TMPINT3,".",TMPINT4,".",TMPINT5;
    Label_62:
    IF ( ! (TMPINT==BPW) ) THEN GOTO Label_63;
    IF ( ! ( ( (CURRPGM==FP3)||(CURRPGM==FP4))||(CURRPGM==FP5)) ) THEN GOTO NOT_FP3_FP4_BPW;
    PRINT "NOTE: The BP Windows version number below should be converted to HEX.";
    NOT_FP3_FP4_BPW:
    PRINT "Software: BP Win v",TMPINT3,".",TMPINT4,".",TMPINT5;
    Label_63:
    LABEL_SEPARATOR = 0;
    Label_64:
    PRINT "=========================================";
ENDPROC;

PROCEDURE READ_F_ROW USES GV;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $c0;
    WAIT IDLE, 1 CYCLES;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $f9;
    DRSCAN 3, FADDR[];
    WAIT IDLE, 1 CYCLES;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $bf;
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 165 USEC;
    DRSCAN 128, $00000000000000000000000000000000, CAPTURE BUFF128[];
ENDPROC;

PROCEDURE DO_DEVICE_INFO USES GV,NVM_R,DO_READ_SECURITY,READ_UROW,DISPLAY_UROW,READ_F_ROW;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $0e;
    WAIT IDLE, 1 CYCLES;
    DRSCAN 32, $00000000, CAPTURE BUFF32[];
    EXPORT "SILSIG", BUFF32[];
    IRSCAN 8, $84, CAPTURE BUFF128[7..0];
    IF ( ! (BUFF128[2]==1) ) THEN GOTO CORE_NOT_ENABLED;
    PRINT "FPGA Array is programmed and enabled.";
    CORE_NOT_ENABLED:
    IF ( ! (BUFF128[2]==0) ) THEN GOTO CORE_ENABLED;
    PRINT "FPGA Array is not enabled.";
    CORE_ENABLED:
    BDISPIAPUROW = 0;
    CALL READ_UROW;
    CALL DISPLAY_UROW;
    CALL DO_READ_SECURITY;
    IF ( ! (ULNC0==0) ) THEN GOTO ENCRYPTED;
    BDISPIAPUROW = 1;
    CALL READ_UROW;
    ENCRYPTED:
    IF ( ! (ULNC0==1) ) THEN GOTO NOT_ENCRYPTED;
    BDISPIAPUROW = 0;
    PRINT "WARNING: Embedded Flash Memory Block (EFMB) block 0 Encryption is enforced. ";
    PRINT "Pass key is needed to read IAP User Row Information from EFMB.";
    PRINT "=========================================";
    NOT_ENCRYPTED:
    IF ( ! (BDISPIAPUROW==1) ) THEN GOTO SKIP_DISP_IAP_UROW;
    CALL DISPLAY_UROW;
    SKIP_DISP_IAP_UROW:
    IF ( ! ( (ULNC0==0)&&(BDISPIAPUROW==0)) ) THEN GOTO DISPLAYED_IAP_UROW;
    PRINT "Device has not been programmed with IAP.";
    PRINT "=========================================";
    DISPLAYED_IAP_UROW:
    FADDR[] = $0;
    CALL READ_F_ROW;
    EXPORT "FSN", BUFF128[55..8];
    PRINT "=========================================";
ENDPROC;

PROCEDURE INIT_AES;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $dd;
    DRSCAN 128, $00000000000000000000000000000000;
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 165 USEC;
ENDPROC;

PROCEDURE DO_VERIFY_DEVICE_INFO USES GV,BITSTREAM,DO_EXIT,DO_READ_SECURITY,READ_UROW
    ,DISP_CHKSUM_DESIGN;
    CALL READ_UROW;
    CALL DISP_CHKSUM_DESIGN;
    CALL DO_READ_SECURITY;
    BUFF32[31..0] = BOOL(CHECKSUM);
    UROW[127..112] = BUFF32[15..0];
    UROW[101..32] = ACT_UROW_DESIGN_NAME[69..0];
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $c0;
    WAIT IDLE, 1 CYCLES;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $a8;
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 165 USEC;
    DRSCAN 128, $00000000000000000000000000000000,COMPARE UROW[],$ffff003fffffffffffffffff00000000
        ,PASS;
    IF ( ! (PASS==0) ) THEN GOTO UROW_CMP_OK;
    STATUS = -43;
    PRINT "Failed to verify design information.";
    UNIQUEEXITCODE = 32772;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    UROW_CMP_OK:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE READ_IDCODE_ONLY USES GV;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $0f;
    WAIT IDLE, 1 CYCLES;
    DRSCAN 32, $00000000, CAPTURE ID[];
    EXPORT "IDCODE", ID[];
ENDPROC;

PROCEDURE VERIFY_RLOCK USES GV;
    IRSCAN 8, $84,COMPARE $04,$04,PASS;
ENDPROC;

PROCEDURE DO_VERIFY_PGM_RLOCK USES GV,DO_EXIT,VERIFY_RLOCK;
    CALL VERIFY_RLOCK;
    IF ( ! (PASS==0) ) THEN GOTO RLOCK_PGM_PASS;
    STATUS = 10;
    PRINT "Failed to enable FPGA Array.";
    UNIQUEEXITCODE = 32891;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    RLOCK_PGM_PASS:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_VERIFY_DISABLE_RLOCK USES GV,DO_EXIT,VERIFY_RLOCK;
    CALL VERIFY_RLOCK;
    IF ( ! (PASS==1) ) THEN GOTO RLOCK_PGM_FAIL;
    STATUS = 10;
    PRINT "Failed to disable FPGA Array.";
    UNIQUEEXITCODE = 32918;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    RLOCK_PGM_FAIL:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_VERIFY_RLOCK USES GV,DO_EXIT,VERIFY_RLOCK;
    CALL VERIFY_RLOCK;
    IF ( ! (PASS==0) ) THEN GOTO RLOCK_VERIFY_PASS;
    STATUS = 11;
    PRINT "FPGA Array is not enabled.";
    UNIQUEEXITCODE = 32892;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    RLOCK_VERIFY_PASS:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE VERIFY_ID_DMK USES GV,DO_EXIT,INIT_AES;
    CALL INIT_AES;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $0a;
    DRSCAN 128, M7BUFF[];
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 90 USEC;
    DRSCAN 128, $00000000000000000000000000000000, CAPTURE BUFF128[],COMPARE $c0000000000000000000000000000000
        ,$c0000000000000000000000000000000,PASS;
    IF ( ! (BUFF128[127]==0) ) THEN GOTO M7VERDONE;
    STATUS = -31;
    PRINT "Failed to verify AES Sec.";
    UNIQUEEXITCODE = 32775;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    M7VERDONE:
    IF ( ! ( (BUFF128[126]==0)||(BM7DEVICE==0)) ) THEN GOTO MXIDOK;
    IF ( ! ( (BUFF128[126]==1)&&(BM7DEVICE==0)) ) THEN GOTO LDETECTM1;
    STATUS = 6;
    PRINT "Failed to verify IDCODE.";
    PRINT "Target is an M7 device.";
    UNIQUEEXITCODE = 32776;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    LDETECTM1:
    IF ( ! (BUFF128[126]==0) ) THEN GOTO Label_67;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $0a;
    DRSCAN 128, M1BUFF[];
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 90 USEC;
    DRSCAN 128, $00000000000000000000000000000000, CAPTURE BUFF128[],COMPARE $c0000000000000000000000000000000
        ,$c0000000000000000000000000000000,PASS;
    IF ( ! (BUFF128[127]==0) ) THEN GOTO M1VERDONE;
    STATUS = -31;
    PRINT "Failed to verify AES Sec.";
    UNIQUEEXITCODE = 32777;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    M1VERDONE:
    BOOLEAN BTMPBUFFBIT126 = BUFF128[126];
    IF ( ! ( (BTMPBUFFBIT126==1)&&(BM1DEVICE==0)) ) THEN GOTO REGDEV;
    STATUS = 6;
    PRINT "Failed to verify IDCODE.";
    PRINT "Target is an M1 device.";
    UNIQUEEXITCODE = 32778;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    REGDEV:
    IF ( ! ( (BTMPBUFFBIT126==0)&&(BM7DEVICE==1)) ) THEN GOTO Label_65;
    STATUS = 6;
    PRINT "Failed to verify IDCODE.";
    PRINT "The Target is not an M7 Device.";
    UNIQUEEXITCODE = 32781;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_65:
    IF ( ! ( (BTMPBUFFBIT126==0)&&(BM1DEVICE==1)) ) THEN GOTO Label_66;
    STATUS = 6;
    PRINT "Failed to verify IDCODE.";
    PRINT "The Target is not an M1 Device.";
    UNIQUEEXITCODE = 32782;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_66:
    LABEL_SEPARATOR = 0;
    Label_67:
    LABEL_SEPARATOR = 0;
    MXIDOK:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE VERIFY_IDCODE USES GV,PARAMETERS,DO_EXIT,VERIFY_ID_DMK;
    FREQUENCY (FREQ*1000000);
    WAIT RESET, 5 CYCLES;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $0f;
    DRSCAN 32, $00000000;
    WAIT IDLE, 1 CYCLES;
    DRSCAN 32, $00000000, CAPTURE ID[],COMPARE IDCODEVALUE[],IDMASK[],PASS;
    IF ( ! (PASS==0) ) THEN GOTO IDOK;
    STATUS = 6;
    PRINT "Failed to verify IDCODE";
    UNIQUEEXITCODE = 32797;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    IDOK:
    CALL VERIFY_ID_DMK;
    IDREV = INT(ID[31..28]);
    IDFAB = INT(ID[25..25]);
ENDPROC;

PROCEDURE IS_SECOK USES GV,DO_EXIT;
    IF ( ! (SECKEY_OK==0) ) THEN GOTO SECOK;
    STATUS = -35;
    PRINT "Failed to match pass key.";
    UNIQUEEXITCODE = 32799;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    SECOK:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_CHECK_R USES GV,DO_EXIT,DO_READ_SECURITY;
    CALL DO_READ_SECURITY;
    IF ( ! (ULARE==1) ) THEN GOTO ARRAYEPR;
    STATUS = -33;
    PRINT "FPGA Array Encryption is enforced. Plain text verification is prohibited.";
    UNIQUEEXITCODE = 32800;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    ARRAYEPR:
    IF ( ! (ULARD==1) ) THEN GOTO SKIPRCHK1;
    STATUS = -30;
    PRINT "FPGA Array Verification is protected by pass key.";
    PRINT "A valid pass key needs to be provided.";
    UNIQUEEXITCODE = 32804;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    SKIPRCHK1:
    IF ( ! (ULARD==0) ) THEN GOTO Label_68;
    CHKSEC = 0;
    Label_68:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_CHECK_W USES GV,DO_EXIT,DO_READ_SECURITY;
    CALL DO_READ_SECURITY;
    IF ( ! (ULAWE==1) ) THEN GOTO ARRAYWP;
    STATUS = -28;
    PRINT "FPGA Array Write/Erase is protected by pass key.";
    PRINT "A valid pass key needs to be provided.";
    UNIQUEEXITCODE = 32805;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    ARRAYWP:
    IF ( ! (ULARD==1) ) THEN GOTO ARRAYRPW;
    STATUS = -30;
    PRINT "FPGA Array Verification is protected by pass key.";
    PRINT "A valid pass key needs to be provided.";
    UNIQUEEXITCODE = 32806;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    ARRAYRPW:
    IF ( ! (ULARE==1) ) THEN GOTO ARRAYEPW;
    STATUS = -33;
    PRINT "FPGA Array Encryption is enforced. Plain text programming is prohibited.";
    CALL DO_EXIT;
    ARRAYEPW:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_CHECK_NVM_0_W USES GV,DO_EXIT,DO_READ_SECURITY;
    CALL DO_READ_SECURITY;
    IF ( ! (ULNW0==1) ) THEN GOTO Label_69;
    STATUS = -48;
    PRINT "Embedded Flash Memory Block (EFMB) block 0 Write is protected by pass key.";
    PRINT "A valid pass key needs to be provided.";
    UNIQUEEXITCODE = 32817;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_69:
    IF ( ! (ULNC0==1) ) THEN GOTO Label_70;
    STATUS = -47;
    PRINT "Embedded Flash Memory Block (EFMB) block 0 Encryption is enforced.";
    PRINT "A programming file with encrypted EFMB data needs to be provided.";
    UNIQUEEXITCODE = 32818;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_70:
    IF ( ! (ULNR0==1) ) THEN GOTO Label_71;
    STATUS = -46;
    PRINT "Embedded Flash Memory Block (EFMB) block 0 Read is protected by pass key.";
    PRINT "A valid pass key needs to be provided.";
    UNIQUEEXITCODE = 32819;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_71:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_CHECK_NVM_0_R USES GV,DO_EXIT,DO_READ_SECURITY;
    CALL DO_READ_SECURITY;
    IF ( ! (ULNR0==1) ) THEN GOTO Label_72;
    STATUS = -46;
    PRINT "Embedded Flash Memory Block (EFMB) block 0 Read is protected by pass key.";
    PRINT "A valid pass key needs to be provided.";
    UNIQUEEXITCODE = 32837;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_72:
    IF ( ! ( (ULUPC==1)&&(ULNR0==0)) ) THEN GOTO Label_73;
    CHKSEC = 0;
    Label_73:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE BP_VER USES GV;
    BOOLEAN PLAYER_VERSION_BOOLEAN[32];
    PLAYER_VERSION_BOOLEAN[31..0] = BOOL(PLAYERVERSIONVARIABLE);
    INTEGER PLAYER_MAJOR_VERSION =(INT(PLAYER_VERSION_BOOLEAN[23..16])-SCULPTORMAJORBASE);
    INTEGER PLAYER_MINOR_VERSION =(INT(PLAYER_VERSION_BOOLEAN[15..8])-SCULPTORMINORBASE);
    ACT_UROW_SW_VERSION[6..5] = BOOL(PLAYER_MAJOR_VERSION);
    ACT_UROW_SW_VERSION[4..1] = BOOL(PLAYER_MINOR_VERSION);
    ACT_UROW_SW_VERSION[0] = PLAYER_VERSION_BOOLEAN[0];
    ACT_UROW_PROGRAM_SW[3..0] = BOOL(PLAYERVERSIONSWVARIABLE);
ENDPROC;

PROCEDURE X USES GV;
    INTEGER K1 =INT(VAR[31..0]);
    INTEGER K2 =INT(VAR[63..32]);
    INTEGER K3 =INT(VAR[95..64]);
    INTEGER K4 =INT(VAR[127..96]);
    IF ( ! ( ( ( (K1==0)&&(K2==0))&&(K3==0))&&(K4==0)) ) THEN GOTO Label_74;
    PERMLOCK = 1;
    Label_74:
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $92;
    DRSCAN 128, VAR[];
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 1250 USEC;
    DRSCAN 128, $00000000000000000000000000000000,COMPARE $00000000000000000000000000000001
        ,$00000000000000000000000000000003,PASS;
    SECKEY_OK = 0;
    IF ( ! (PASS==1) ) THEN GOTO Label_75;
    SECKEY_OK = 1;
    Label_75:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE POLL_PROGRAM USES GV;
    INTEGER ILOOP_0;
    FOR ILOOP_0 = 16381 - 1 TO 0 STEP -1;
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $84;
        WAIT IDLE, 1 CYCLES;
        WAIT IDLE, 100 USEC;
        DRSCAN 5, $00,COMPARE $00,$0b,PASS;
        IF PASS THEN ILOOP_0 = 0;
    NEXT ILOOP_0;
ENDPROC;

PROCEDURE Y USES GV,POLL_PROGRAM;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $8b;
    DRSCAN 128, VAR[];
    WAIT IDLE, 3 CYCLES;
    CALL POLL_PROGRAM;
ENDPROC;

PROCEDURE Z USES GV,DO_READ_SECURITY,X,Y;
    CALL DO_READ_SECURITY;
    IF ( ! ( ( (ULULR==0)&&(ULFLR==0))&&(ULUPC==0)) ) THEN GOTO SECURED_DEV;
    CALL Y;
    SECURED_DEV:
    CALL X;
ENDPROC;

PROCEDURE SET_NVM_ACTIVE_ARRAY USES NVM_V;
    NVMACTIVEARRAY = 1;
ENDPROC;

PROCEDURE SET_PRG_ARRAY USES GV;
    ISPRGARRAY = 1;
ENDPROC;

PROCEDURE DO_INITIALIZE_ACCESS_NVM USES NVM_V,GV,DO_EXIT_ACCESS_NVM;
    NVMACCESS[0] = 1;
    NVMMASK[0] = 1;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $b6;
    DRSCAN 5, NVMACCESS[];
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 2 USEC;
    DRSCAN 5, $00, CAPTURE NVMBUSY[],COMPARE $00,NVMMASK[],PASS;
    IF ( ! (PASS==0) ) THEN GOTO Label_76;
    WAIT 100 USEC;
    INTEGER ILOOP_1;
    FOR ILOOP_1 = MAXATTEMPTNVMACCESS - 1 TO 0 STEP -1;
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $b6;
        DRSCAN 5, NVMACCESS[];
        WAIT IDLE, 3 CYCLES;
        WAIT IDLE, 2 USEC;
        DRSCAN 5, $00, CAPTURE NVMBUSY[],COMPARE $00,NVMMASK[],PASS;
        IF PASS THEN ILOOP_1 = 0;
    NEXT ILOOP_1;
    Label_76:
    IF ( ! (PASS==0) ) THEN GOTO Label_77;
    STATUS = -54;
    PRINT "Failed to access Embedded Flash Memory.";
    EXPORT "nvmBusy", NVMBUSY[];
    EXPORT "nvmAccess", NVMACCESS[];
    UNIQUEEXITCODE = 32849;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT_ACCESS_NVM;
    Label_77:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_SWITCH USES GV;
    IF ( ! (SAMPLEMASK[BSROINDEX]==1) ) THEN GOTO NOTSAMPLINGOUTPUT;
    BSR[BSROINDEX] = SAMPLE_DEVICE[(BSROINDEX+1)];
    NOTSAMPLINGOUTPUT:
    IF ( ! (SAMPLEMASK[(BSROINDEX+1)]==1) ) THEN GOTO NOTSAMPLINGOUTPUTENABLE;
    BSR[(BSROINDEX+1)] = SAMPLE_DEVICE[BSROINDEX];
    NOTSAMPLINGOUTPUTENABLE:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_SWITCH_EMI USES GV,DO_SWITCH;
    FOR I = 0 TO 49;
        BSROINDEX = OINDICES[I];
        CALL DO_SWITCH;
    NEXT I;
ENDPROC;

PROCEDURE DO_INITIALIZE USES GV,NVM_V,DO_EXIT,READ_F_ROW,DO_CHECK_R,DO_CHECK_W,DO_CHECK_NVM_0_W
    ,DO_CHECK_NVM_0_R,BP_VER,Z,DO_SWITCH_EMI;
    NVMACTIVEARRAY = 0;
    BSR[884..0] = BSRPATTERN[884..0];
    BOOLEAN SHIFT_DATA[885];
    IRSCAN 8, $01;
    DRSCAN 885, BSR[];
    WAIT IDLE, 1 CYCLES;
    DRSCAN 885, SHIFT_DATA[], CAPTURE SAMPLE_DEVICE[];
    FOR I = 0 TO 884;
        IF ( ! (SAMPLEMASK[I]==1) ) THEN GOTO Label_78;
        BSR[I] = SAMPLE_DEVICE[I];
        Label_78:
        LABEL_SEPARATOR = 0;
    NEXT I;
    IF ( ! ( (IDFAB==0)&&(IDREV==0)) ) THEN GOTO NOEMISWAPNEEDED;
    CALL DO_SWITCH_EMI;
    NOEMISWAPNEEDED:
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $01;
    DRSCAN 885, BSR[];
    WAIT IDLE, 1 CYCLES;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $c0;
    WAIT IDLE, 1 CYCLES;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $80;
    DRSCAN 18, $00000;
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 1875 USEC;
    DRSCAN 18, $00000, CAPTURE ISC_CONFIG_RESULT[],COMPARE $30000,$30000,PASS;
    IF ( ! (PASS==0) ) THEN GOTO CRCOK;
    STATUS = 5;
    PRINT "Failed to enter programming mode.";
    EXPORT "ISC_Config_Result", ISC_CONFIG_RESULT[];
    UNIQUEEXITCODE = 32850;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    CRCOK:
    FADDR[] = $0;
    CALL READ_F_ROW;
    EXPORT "FSN", BUFF128[55..8];
    CALL Z;
    IF ( ! (CHKARRAY==1) ) THEN GOTO SKIPCHKARRAY;
    IF ( ! (ARRAYRONLY==0) ) THEN GOTO Label_79;
    CALL DO_CHECK_W;
    Label_79:
    IF ( ! (ARRAYRONLY==1) ) THEN GOTO Label_80;
    CALL DO_CHECK_R;
    Label_80:
    LABEL_SEPARATOR = 0;
    SKIPCHKARRAY:
    IF ( ! (CHKNVM==1) ) THEN GOTO Label_83;
    IF ( ! (NVM0RONLY==0) ) THEN GOTO Label_81;
    CALL DO_CHECK_NVM_0_W;
    Label_81:
    IF ( ! (NVM0RONLY==1) ) THEN GOTO Label_82;
    CALL DO_CHECK_NVM_0_R;
    Label_82:
    LABEL_SEPARATOR = 0;
    Label_83:
    IF ( ! (PLAYERVERSIONVARIABLE!=0) ) THEN GOTO Label_84;
    CALL BP_VER;
    Label_84:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE READ_INITIALIZE USES GV,DO_INITIALIZE;
    CHKFROM = 0;
    CHKARRAY = 0;
    CHKNVM = 0;
    CHKSEC = 0;
    CALL DO_INITIALIZE;
ENDPROC;

PROCEDURE NW_INITIALIZE_COMMON USES GV;
    CHKNVM = 1;
    NVM0RONLY = 0;
    CHKFROM = 0;
    CHKARRAY = 0;
ENDPROC;

PROCEDURE NW_INITIALIZE_ACCESS_NVM USES DO_INITIALIZE_ACCESS_NVM,NW_INITIALIZE_COMMON;
    CALL NW_INITIALIZE_COMMON;
    CALL DO_INITIALIZE_ACCESS_NVM;
ENDPROC;

PROCEDURE NW_INITIALIZE USES DO_INITIALIZE,NW_INITIALIZE_COMMON;
    CALL NW_INITIALIZE_COMMON;
    CALL DO_INITIALIZE;
ENDPROC;

PROCEDURE NR_INITIALIZE_COMMON USES GV;
    CHKNVM = 1;
    NVM0RONLY = 1;
    CHKFROM = 0;
    CHKARRAY = 0;
ENDPROC;

PROCEDURE NR_INITIALIZE USES DO_INITIALIZE,NR_INITIALIZE_COMMON;
    CALL NR_INITIALIZE_COMMON;
    CALL DO_INITIALIZE;
ENDPROC;

PROCEDURE NR_INITIALIZE_ACCESS_NVM USES DO_INITIALIZE_ACCESS_NVM,NR_INITIALIZE_COMMON;
    CALL NR_INITIALIZE_COMMON;
    CALL DO_INITIALIZE_ACCESS_NVM;
ENDPROC;

PROCEDURE AW_INITIALIZE USES GV,DO_INITIALIZE;
    ARRAYRONLY = 0;
    CHKFROM = 0;
    CHKARRAY = 1;
    CHKNVM = 0;
    CALL DO_INITIALIZE;
ENDPROC;

PROCEDURE AR_INITIALIZE USES GV,DO_INITIALIZE;
    ARRAYRONLY = 1;
    CHKFROM = 0;
    CHKARRAY = 1;
    CHKNVM = 0;
    CALL DO_INITIALIZE;
ENDPROC;

PROCEDURE W_INITIALIZE USES GV,DO_INITIALIZE;
    ARRAYRONLY = 0;
    CHKARRAY = 1;
    CHKNVM = 1;
    NVM0RONLY = 0;
    CALL DO_INITIALIZE;
ENDPROC;

PROCEDURE R_INITIALIZE USES GV,DO_INITIALIZE;
    ARRAYRONLY = 1;
    CHKARRAY = 1;
    CHKNVM = 1;
    NVM0RONLY = 1;
    CALL DO_INITIALIZE;
ENDPROC;

PROCEDURE INITIALIZE USES GV,DO_INITIALIZE;
    ARRAYRONLY = 0;
    FROMRONLY = 0;
    NVM0RONLY = 1;
    CHKFROM = 1;
    CHKARRAY = 1;
    CHKNVM = 1;
    CALL DO_INITIALIZE;
ENDPROC;

PROCEDURE POLL_ERASE USES GV;
    PASS = 0;
    INTEGER ILOOP_2;
    FOR ILOOP_2 = 262141 - 1 TO 0 STEP -1;
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $84;
        WAIT IDLE, 1 CYCLES;
        WAIT IDLE, 1000 USEC;
        DRSCAN 5, $00,COMPARE $00,$03,PASS;
        IF PASS THEN ILOOP_2 = 0;
    NEXT ILOOP_2;
ENDPROC;

PROCEDURE UFROM_DISTURB USES GV;
    FOR FROMROWNUMBER = NUMBEROFFROMROWS TO 1 STEP -1;
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $9f;
        DRSCAN 3, BOOL((FROMROWNUMBER-1));
        WAIT IDLE, 1 CYCLES;
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $9b;
        DRSCAN 128, $ffffffffffffffffffffffffffffffff;
        WAIT IDLE, 5 CYCLES;
        WAIT IDLE, 10000 USEC;
    NEXT FROMROWNUMBER;
ENDPROC;

PROCEDURE PROGRAM_UROW USES GV,BITSTREAM,DO_EXIT,POLL_PROGRAM;
    IF ( ! (ISERASEONLY==0) ) THEN GOTO SKIP_CYC_INCREMENT;
    IF ( ! (ISPRGARRAY==1) ) THEN GOTO NOT_PGM_ARRAY;
    IF ( ! ( ( ( (INT(UROW[31..0])==-1)&&(INT(UROW[63..32])==-1))&&(INT(UROW[95..64])==-1))&&(INT(UROW[127..96])==-1)) ) THEN GOTO NOT_CORRUPTED_CYCLE_COUNT;
    ACT_UROW_CYCLE_COUNT = 0;
    NOT_CORRUPTED_CYCLE_COUNT:
    IF ( ! (ACT_UROW_CYCLE_COUNT<1000) ) THEN GOTO MAX_CYCLE_COUNT;
    ACT_UROW_CYCLE_COUNT = (ACT_UROW_CYCLE_COUNT+1);
    MAX_CYCLE_COUNT:
    LABEL_SEPARATOR = 0;
    NOT_PGM_ARRAY:
    LABEL_SEPARATOR = 0;
    SKIP_CYC_INCREMENT:
    IF ( ! (ISERASEONLY==1) ) THEN GOTO Label_85;
    UROW[] = $ffffffffffffffffffffffffffffffff;
    Label_85:
    IF ( ! ( (ISERASEONLY==0)||(ISRESTOREDESIGN==1)) ) THEN GOTO SKIP_DESIGN_INFO;
    BUFF32[31..0] = BOOL(CHECKSUM);
    IF ( ! ( !ISRESTOREDESIGN) ) THEN GOTO Label_86;
    UROW[127..112] = BUFF32[15..0];
    Label_86:
    IF ( ! ISRESTOREDESIGN ) THEN GOTO Label_87;
    UROW[127..112] = SUROWCHECKSUM[15..0];
    Label_87:
    IF ( ! ( !ISRESTOREDESIGN) ) THEN GOTO Label_88;
    UROW[101..32] = ACT_UROW_DESIGN_NAME[69..0];
    Label_88:
    IF ( ! ISRESTOREDESIGN ) THEN GOTO Label_89;
    UROW[101..32] = SUROWDESIGNNAME[69..0];
    Label_89:
    LABEL_SEPARATOR = 0;
    SKIP_DESIGN_INFO:
    BUFF32[31..0] = BOOL(ACT_UROW_CYCLE_COUNT);
    UROW[111..102] = BUFF32[9..0];
    UROW[31..29] = ACT_UROW_PROG_METHOD[2..0];
    UROW[28..25] = ACT_UROW_ALGO_VERSION[3..0];
    UROW[16..10] = ACT_UROW_SW_VERSION[6..0];
    UROW[9..6] = ACT_UROW_PROGRAM_SW[3..0];
    UROW[4] = SUROW_SRAM_DISTURB[0];
    IF ( ! (ACT_UROW_ALGO_VERSION[6]==1) ) THEN GOTO Label_90;
    UROW[5] = 1;
    UROW[0] = 0;
    UROW[24..23] = ACT_UROW_ALGO_VERSION[5..4];
    Label_90:
    IF ( ! (ACT_UROW_ALGO_VERSION[6]==0) ) THEN GOTO Label_91;
    UROW[5] = 0;
    UROW[0] = 1;
    UROW[24..23] = ACT_UROW_ALGO_VERSION[5..4];
    Label_91:
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $a7;
    DRSCAN 128, UROW[];
    WAIT IDLE, 15 CYCLES;
    CALL POLL_PROGRAM;
    IF ( ! (PASS==0) ) THEN GOTO PROGRAM_OK3;
    STATUS = -24;
    PRINT "Failed to program UROW";
    UNIQUEEXITCODE = 32853;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    PROGRAM_OK3:
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $c0;
    WAIT IDLE, 1 CYCLES;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $a8;
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 165 USEC;
    DRSCAN 128, $00000000000000000000000000000000,COMPARE UROW[],UROW_MASK[],PASS;
    IF ( ! (PASS==0) ) THEN GOTO UROW_OK;
    STATUS = -24;
    PRINT "Failed to program UROW";
    UNIQUEEXITCODE = 32854;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    UROW_OK:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE FAIL_ERASE USES GV,DO_EXIT;
    STATUS = 8;
    PRINT "Failed Erase Operation";
    UNIQUEEXITCODE = 32855;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
ENDPROC;

PROCEDURE EXE_ERASE USES BITSTREAM,GV,READ_UROW,POLL_ERASE,PROGRAM_UROW,FAIL_ERASE;
    IF ( ! (COMBERASESELECT[14]==1) ) THEN GOTO SKIPRUROW;
    CALL READ_UROW;
    EXPORT "ACTEL_SLOG_UROW", UROW[];
    SKIPRUROW:
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $85;
    DRSCAN 23, COMBERASESELECT[];
    WAIT IDLE, 3 CYCLES;
    CALL POLL_ERASE;
    IF ( ! (PASS==0) ) THEN GOTO ERASEOK;
    CALL FAIL_ERASE;
    ERASEOK:
    IF ( ! (COMBERASESELECT[14]==1) ) THEN GOTO Label_92;
    CALL PROGRAM_UROW;
    Label_92:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_ERASE USES BITSTREAM,GV,EXE_ERASE;
    PRINT "Erase ...";
    COMBERASESELECT[22..0] = $004000;
    IF ( ! ( ( (ULULR==0)&&(ULFLR==0))&&(ULUPC==0)) ) THEN GOTO DEVICE_SECURED_ERASE;
    COMBERASESELECT[3..3] = $1;
    DEVICE_SECURED_ERASE:
    COMBERASESELECT[0] = 1;
    CALL EXE_ERASE;
    PRINT "Completed erase";
    IF ( ! (ISPRGARRAY==1) ) THEN GOTO NOT_PGM_ARRAY_ERASE;
    BUFF32[31..0] = BOOL(CHECKSUM);
    EXPORT "CHECKSUM", BUFF32[15..0];
    NOT_PGM_ARRAY_ERASE:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_ERASE_ARRAY USES GV,EXE_ERASE;
    PRINT "Erase FPGA Array ...";
    COMBERASESELECT[22..0] = $004001;
    CALL EXE_ERASE;
ENDPROC;

PROCEDURE DO_ERASE_ONLY USES GV,DO_ERASE;
    ISERASEONLY = 1;
    CALL DO_ERASE;
ENDPROC;

PROCEDURE DO_ERASE_ARRAY_ONLY USES GV,DO_ERASE_ARRAY;
    ISERASEONLY = 1;
    CALL DO_ERASE_ARRAY;
ENDPROC;

PROCEDURE DO_ERASE_ALL USES GV,UFROM_DISTURB,EXE_ERASE;
    IF ( ! ( (BM7DEVICE==1)||(BM1DEVICE==1)) ) THEN GOTO Label_93;
    PRINT "Erase FPGA Array and FlashROM ...";
    Label_93:
    IF ( ! ( (BM7DEVICE!=1)&&(BM1DEVICE!=1)) ) THEN GOTO Label_94;
    PRINT "Erase FPGA Array, FlashROM and Security Settings ...";
    Label_94:
    COMBERASESELECT[22..0] = $7fc00f;
    ISERASEONLY = 1;
    CALL EXE_ERASE;
    CALL UFROM_DISTURB;
ENDPROC;

PROCEDURE LOAD_ROW_DATA USES BITSTREAM,GV;
    FOR SDTILE = 1 TO NUMBEROFSDTILES;
        FOR I = 1 TO 8;
            IRSTOP IRPAUSE;
            DRSTOP DRPAUSE;
            IRSCAN 8, $89;
            DRSCAN 26, DATASTREAM[(DATAINDEX+25)..DATAINDEX];
            WAIT IDLE, 3 CYCLES;
            DATAINDEX = (DATAINDEX+26);
        NEXT I;
    NEXT SDTILE;
ENDPROC;

PROCEDURE EXE_PROGRAM USES GV,DO_EXIT,POLL_PROGRAM;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $83;
    WAIT IDLE, 3 CYCLES;
    CALL POLL_PROGRAM;
    IF ( ! (PASS==0) ) THEN GOTO Label_95;
    STATUS = 10;
    PRINT "Failed to program FPGA array at row ",ROWNUMBER,".";
    UNIQUEEXITCODE = 32856;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_95:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE EXE_VERIFY USES GV,DO_EXIT,POLL_PROGRAM;
    IF ( ! (VERIFYEOL[0]==0) ) THEN GOTO VERIFY_EOL_0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $8d;
    DRSCAN 2, VERIFYEOL[];
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 264 USEC;
    CALL POLL_PROGRAM;
    IF ( ! (PASS==0) ) THEN GOTO Label_96;
    STATUS = 11;
    PRINT "Verify 0 failed at row ",ROWNUMBER,".";
    UNIQUEEXITCODE = 32857;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_96:
    IRSCAN 8, $8d;
    DRSCAN 2, VERIFYEOL[],COMPARE $0,$3,PASS;
    VERIFY_EOL_0:
    IF ( ! (VERIFYEOL[0]==1) ) THEN GOTO VERIFY_BOL_0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $8d;
    DRSCAN 2, VERIFYEOL[];
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 1250 USEC;
    DRSCAN 2, $0,COMPARE $0,$3,PASS;
    VERIFY_BOL_0:
    IF ( ! (PASS==0) ) THEN GOTO Label_97;
    STATUS = 11;
    PRINT "Verify 0 failed at row ",ROWNUMBER,".";
    UNIQUEEXITCODE = 32858;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_97:
    IF ( ! (VERIFYEOL[0]==0) ) THEN GOTO VERIFY_EOL_1;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $8e;
    DRSCAN 2, VERIFYEOL[];
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 264 USEC;
    CALL POLL_PROGRAM;
    IF ( ! (PASS==0) ) THEN GOTO Label_98;
    STATUS = 11;
    PRINT "Verify 1 failed at row ",ROWNUMBER,".";
    UNIQUEEXITCODE = 32859;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_98:
    IRSCAN 8, $8e;
    DRSCAN 2, VERIFYEOL[],COMPARE $0,$3,PASS;
    VERIFY_EOL_1:
    IF ( ! (VERIFYEOL[0]==1) ) THEN GOTO VERIFY_BOL_1;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $8e;
    DRSCAN 2, VERIFYEOL[];
    WAIT IDLE, 3 CYCLES;
    WAIT IDLE, 1250 USEC;
    DRSCAN 2, $0,COMPARE $0,$3,PASS;
    VERIFY_BOL_1:
    IF ( ! (PASS==0) ) THEN GOTO Label_99;
    STATUS = 11;
    PRINT "Verify 1 failed at row ",ROWNUMBER,".";
    UNIQUEEXITCODE = 32860;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_99:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_PROGRAM USES GV,LOAD_ROW_DATA,EXE_PROGRAM;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $87;
    DRSCAN 2, $2;
    WAIT IDLE, 3 CYCLES;
    PRINT "Programming FPGA Array";
    DATAINDEX = 0;
    ROWNUMBER = (NUMBEROFMAPROWS-1);
    INTEGER IREPEAT_1;
    FOR IREPEAT_1 = NUMBEROFMAPROWS - 1 TO 0 STEP -1;
        CALL LOAD_ROW_DATA;
        CALL EXE_PROGRAM;
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $87;
        DRSCAN 2, $3;
        WAIT IDLE, 3 CYCLES;
        IF ( ! ((ROWNUMBER%ROWITERATION)==0) ) THEN GOTO Label_100;
        PERCENT_UPDATE = ((100*((NUMBEROFMAPROWS-ROWNUMBER)+1))/NUMBEROFMAPROWS);
        DIFFERENCE = (PERCENT_UPDATE%10);
        IF ( ! (DIFFERENCE>=5) ) THEN GOTO ROUND_DOWN_PGM_A;
        PERCENT_UPDATE = (PERCENT_UPDATE+(10-DIFFERENCE));
        ROUND_DOWN_PGM_A:
        IF ( ! (DIFFERENCE<5) ) THEN GOTO ROUND_UP_PGM_A;
        PERCENT_UPDATE = (PERCENT_UPDATE-DIFFERENCE);
        ROUND_UP_PGM_A:
        EXPORT "PERCENT_DONE", PERCENT_UPDATE;
        Label_100:
        ROWNUMBER = (ROWNUMBER-1);
    NEXT IREPEAT_1;
ENDPROC;

PROCEDURE DO_VERIFY USES GV,LOAD_ROW_DATA,EXE_VERIFY;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $87;
    DRSCAN 2, $2;
    WAIT IDLE, 3 CYCLES;
    PRINT "Verifying FPGA Array";
    DATAINDEX = 0;
    ROWNUMBER = (NUMBEROFMAPROWS-1);
    INTEGER IREPEAT_2;
    FOR IREPEAT_2 = NUMBEROFMAPROWS - 1 TO 0 STEP -1;
        CALL LOAD_ROW_DATA;
        CALL EXE_VERIFY;
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $87;
        DRSCAN 2, $3;
        WAIT IDLE, 3 CYCLES;
        IF ( ! ((ROWNUMBER%ROWITERATION)==0) ) THEN GOTO Label_101;
        PERCENT_UPDATE = ((100*((NUMBEROFMAPROWS-ROWNUMBER)+1))/NUMBEROFMAPROWS);
        DIFFERENCE = (PERCENT_UPDATE%10);
        IF ( ! (DIFFERENCE>=5) ) THEN GOTO ROUND_DOWN_VER_ARRAY;
        PERCENT_UPDATE = (PERCENT_UPDATE+(10-DIFFERENCE));
        ROUND_DOWN_VER_ARRAY:
        IF ( ! (DIFFERENCE<5) ) THEN GOTO ROUND_UP_VER_ARRAY;
        PERCENT_UPDATE = (PERCENT_UPDATE-DIFFERENCE);
        ROUND_UP_VER_ARRAY:
        EXPORT "PERCENT_DONE", PERCENT_UPDATE;
        Label_101:
        ROWNUMBER = (ROWNUMBER-1);
    NEXT IREPEAT_2;
    PRINT "        Verifying FPGA Array -- pass";
ENDPROC;

PROCEDURE DO_VERIFY_BOL USES GV,DO_VERIFY;
    VERIFYEOL[0] = 0;
    CALL DO_VERIFY;
ENDPROC;

PROCEDURE DO_VERIFY_EOL USES GV,DO_VERIFY;
    VERIFYEOL[0] = 1;
    CALL DO_VERIFY;
ENDPROC;

PROCEDURE DO_PROGRAM_RLOCK USES GV,DO_EXIT,POLL_PROGRAM;
    DATAINDEX = 0;
    INTEGER IREPEAT_3;
    FOR IREPEAT_3 = NUMBEROFSDTILES - 1 TO 0 STEP -1;
        FOR I = 1 TO 8;
            IRSTOP IRPAUSE;
            DRSTOP DRPAUSE;
            IRSCAN 8, $89;
            DRSCAN 26, RLOCK[(DATAINDEX+25)..DATAINDEX];
            WAIT IDLE, 3 CYCLES;
            DATAINDEX = (DATAINDEX+26);
        NEXT I;
    NEXT IREPEAT_3;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $8c;
    WAIT IDLE, 3 CYCLES;
    CALL POLL_PROGRAM;
    IF ( ! (PASS==0) ) THEN GOTO Label_102;
    STATUS = 10;
    PRINT "Failed to enable FPGA Array.";
    UNIQUEEXITCODE = 32862;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    Label_102:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_DISABLE_RLOCK USES GV,DO_EXIT,POLL_PROGRAM;
    DATAINDEX = 0;
    INTEGER IREPEAT_4;
    FOR IREPEAT_4 = NUMBEROFSDTILES - 1 TO 0 STEP -1;
        FOR I = 1 TO 8;
            IRSTOP IRPAUSE;
            DRSTOP DRPAUSE;
            IRSCAN 8, $89;
            DRSCAN 26, $0000000;
            WAIT IDLE, 3 CYCLES;
            DATAINDEX = (DATAINDEX+26);
        NEXT I;
    NEXT IREPEAT_4;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $8c;
    WAIT IDLE, 3 CYCLES;
    CALL POLL_PROGRAM;
    IF ( ! (PASS==0) ) THEN GOTO FABRIC_ENABLED;
    STATUS = 10;
    PRINT "Failed to disable FPGA Array.";
    UNIQUEEXITCODE = 32917;
    BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF128[15..0];
    CALL DO_EXIT;
    FABRIC_ENABLED:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DISABLE_RLOCK_AND_VERIFY USES DO_VERIFY_DISABLE_RLOCK,DO_DISABLE_RLOCK;
    CALL DO_DISABLE_RLOCK;
    CALL DO_VERIFY_DISABLE_RLOCK;
ENDPROC;

PROCEDURE DO_READ_IDCODE USES READ_IDCODE_ONLY;
    WAIT RESET, 5 CYCLES;
    CALL READ_IDCODE_ONLY;
    EXIT 0;
ENDPROC;

PROCEDURE DO_PROGRAM_NVM_PRIV USES NVM_V,GV,DO_EXIT,DO_EXIT_ACCESS_NVM,DISP_SF_USER_ADDR
    ,DO_CHECK_NVM_0_W;
    CALL DO_CHECK_NVM_0_W;
    PRINT "Program System Init and Boot Clients...";
    NVMWORDS = (NVMDATASTREAMSIZEPRIV_ALL/32);
    NVMPAGES = (NVMWORDS/32);
    NVMWORDCOUNT = 0;
    NVMDATAINDEX = 0;
    NVMADDRESS[] = $000000000;
    NVMADDRESS[12..11] = $2;
    PROTECTION[] = $00;
    PAR = -1;
    PARWORDCOUNT = 0;
    PARSIZE = 0;
    INTEGER IREPEAT_5;
    FOR IREPEAT_5 = NVMPAGES - 1 TO 0 STEP -1;
        IF ( ! (PARWORDCOUNT==PARSIZE) ) THEN GOTO Label_103;
        PARWORDCOUNT = 0;
        PAR = (PAR+1);
        NVMADDRESS[34..13] = NVMADDRPRIV_ALL[(((PAR+1)*22)-1)..(PAR*22)];
        NVMADDRESS[20] = 0;
        PAGEADDRESS = INT(NVMADDRESS[34..21]);
        PARSIZE = INT(NVMPARSIZEPRIV_ALL[(((PAR+1)*32)-1)..(PAR*32)]);
        PROTECTION[4..2] = NVMPROTECTPRIV_ALL[(((PAR+1)*3)-1)..(PAR*3)];
        Label_103:
        BUFF32[31..0] = BOOL(PAGEADDRESS);
        NVMADDRESS[34..21] = BUFF32[13..0];
        IRSCAN 8, $b8;
        DRSCAN 35, NVMADDRESS[];
        WAIT 3 CYCLES;
        WAIT 20 USEC, DRPAUSE;
        FOR NVMPOLL = 0 TO 10000;
            DRSCAN 35, NVMADDRESS[], CAPTURE BUFF128[34..0],COMPARE $000000000,$400000000
                ,PASS;
            IF ( ! (PASS==1) ) THEN GOTO Label_104;
            NVMPOLL = 10000;
            Label_104:
            IF ( ! (PASS!=1) ) THEN GOTO Label_105;
            IRSCAN 8, $b8;
            WAIT DRPAUSE, 100 USEC, DRPAUSE;
            Label_105:
            LABEL_SEPARATOR = 0;
        NEXT NVMPOLL;
        IF ( ! (PASS==0) ) THEN GOTO NVMADDRSHIFTOK_1_PRIV;
        PRINT "Error programming system init and boot clients.";
        STATUS = 10;
        IF ( ! (NVMACTIVEARRAY==1) ) THEN GOTO Label_106;
        UNIQUEEXITCODE = 32893;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT_ACCESS_NVM;
        Label_106:
        IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO Label_107;
        UNIQUEEXITCODE = 32894;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT;
        Label_107:
        LABEL_SEPARATOR = 0;
        NVMADDRSHIFTOK_1_PRIV:
        FOR I = 1 TO 32;
            IRSTOP IRPAUSE;
            DRSTOP DRPAUSE;
            IRSCAN 8, $b9;
            DRSCAN 32, NVMDATAPRIV_ALL[(NVMDATAINDEX+31)..NVMDATAINDEX];
            WAIT IDLE, 3 CYCLES;
            WAIT IDLE, 5 USEC;
            NVMDATAINDEX = (NVMDATAINDEX+32);
        NEXT I;
        IRSCAN 8, $ba;
        DRSCAN 5, PROTECTION[];
        WAIT 3 CYCLES;
        WAIT 100 USEC, DRPAUSE;
        FOR NVMPOLL = 0 TO 10000;
            DRSCAN 5, PROTECTION[], CAPTURE BUFF128[4..0],COMPARE $00,$10,PASS;
            IF ( ! (PASS==1) ) THEN GOTO Label_108;
            NVMPOLL = 10000;
            Label_108:
            IF ( ! (PASS!=1) ) THEN GOTO Label_109;
            IRSCAN 8, $ba;
            WAIT DRPAUSE, 100 USEC, DRPAUSE;
            Label_109:
            LABEL_SEPARATOR = 0;
        NEXT NVMPOLL;
        IF ( ! ( (BUFF128[2]==1)&&(BUFF128[3]==1)) ) THEN GOTO Label_110;
        PRINT "WARNING: Write count threshold exceeded: ",PAGEADDRESS,".";
        Label_110:
        IF ( ! (PASS==0) ) THEN GOTO CONTPROG_PRIV;
        PRINT "Error programming system init and boot clients.";
        PRINT "Partition : ",PAR;
        PRINT "Word: ",PARWORDCOUNT;
        CALL DISP_SF_USER_ADDR;
        EXPORT "BUSY", BUFF128[4..4];
        EXPORT "PrgStat", BUFF128[3..2];
        EXPORT "NvmStat", BUFF128[1..0];
        BUFF32[31..0] = BOOL(PAGEADDRESS);
        NVMADDRESS[34..21] = BUFF32[];
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $b8;
        DRSCAN 35, NVMADDRESS[];
        WAIT IDLE, 3 CYCLES;
        WAIT IDLE, 20 USEC;
        DRSCAN 35, $000000000, CAPTURE BUFF128[34..0];
        IF ( ! (BUFF128[0]==1) ) THEN GOTO Label_111;
        PRINT "Overwrite Protect ON";
        Label_111:
        IF ( ! (BUFF128[1]==1) ) THEN GOTO Label_112;
        PRINT "Write Protect ON";
        Label_112:
        IF ( ! (BUFF128[2]==1) ) THEN GOTO Label_113;
        PRINT "Read Protect ON";
        Label_113:
        IF ( ! (BUFF128[0]!=1) ) THEN GOTO Label_114;
        PRINT "Overwrite Protect OFF";
        Label_114:
        IF ( ! (BUFF128[1]!=1) ) THEN GOTO Label_115;
        PRINT "Write Protect OFF";
        Label_115:
        IF ( ! (BUFF128[2]!=1) ) THEN GOTO Label_116;
        PRINT "Read Protect OFF";
        Label_116:
        STATUS = 10;
        IF ( ! (NVMACTIVEARRAY==1) ) THEN GOTO Label_117;
        UNIQUEEXITCODE = 32895;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT_ACCESS_NVM;
        Label_117:
        IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO Label_118;
        UNIQUEEXITCODE = 32896;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT;
        Label_118:
        LABEL_SEPARATOR = 0;
        CONTPROG_PRIV:
        PAGEADDRESS = (PAGEADDRESS+1);
        PARWORDCOUNT = (PARWORDCOUNT+32);
        NVMWORDCOUNT = (NVMWORDCOUNT+32);
        IF ( ! (((NVMWORDCOUNT/32)%PAGEITERATION)==0) ) THEN GOTO Label_119;
        PERCENT_UPDATE = ((100*NVMWORDCOUNT)/NVMWORDS);
        DIFFERENCE = (PERCENT_UPDATE%10);
        IF ( ! (DIFFERENCE>=5) ) THEN GOTO ROUND_DOWN_PGM_NVM_PRIV;
        PERCENT_UPDATE = (PERCENT_UPDATE+(10-DIFFERENCE));
        ROUND_DOWN_PGM_NVM_PRIV:
        IF ( ! (DIFFERENCE<5) ) THEN GOTO ROUND_UP_PGM_NVM_PRIV;
        PERCENT_UPDATE = (PERCENT_UPDATE-DIFFERENCE);
        ROUND_UP_PGM_NVM_PRIV:
        EXPORT "PERCENT_DONE", PERCENT_UPDATE;
        Label_119:
        LABEL_SEPARATOR = 0;
    NEXT IREPEAT_5;
ENDPROC;

PROCEDURE DO_VERIFY_NVM_PRIV USES NVM_V,GV,DO_EXIT,DO_EXIT_ACCESS_NVM,DISP_SF_USER_ADDR;
    PRINT "Verify System Init and Boot Clients...";
    NVMWORDS = (NVMDATASTREAMSIZEPRIV_ALL/32);
    NVMPAGES = (NVMWORDS/32);
    NVMWORDCOUNT = 0;
    NVMDATAINDEX = 0;
    NVMADDRESS[] = $000000000;
    NVMADDRESS[12..11] = $2;
    PROTECTION[] = $00;
    PAR = -1;
    PARWORDCOUNT = 0;
    PARSIZE = 0;
    INTEGER IREPEAT_6;
    FOR IREPEAT_6 = NVMPAGES - 1 TO 0 STEP -1;
        IF ( ! (PARWORDCOUNT==PARSIZE) ) THEN GOTO Label_120;
        PARWORDCOUNT = 0;
        PAR = (PAR+1);
        NVMADDRESS[34..13] = NVMADDRPRIV_ALL[(((PAR+1)*22)-1)..(PAR*22)];
        NVMADDRESS[20] = 0;
        PAGEADDRESS = INT(NVMADDRESS[34..21]);
        PARSIZE = INT(NVMPARSIZEPRIV_ALL[(((PAR+1)*32)-1)..(PAR*32)]);
        PROTECTION[4..2] = NVMPROTECTPRIV_ALL[(((PAR+1)*3)-1)..(PAR*3)];
        Label_120:
        BUFF32[31..0] = BOOL(PAGEADDRESS);
        NVMADDRESS[34..21] = BUFF32[13..0];
        IRSCAN 8, $b8;
        DRSCAN 35, NVMADDRESS[];
        WAIT 3 CYCLES;
        WAIT 20 USEC, DRPAUSE;
        FOR NVMPOLL = 0 TO 10000;
            DRSCAN 35, NVMADDRESS[], CAPTURE BUFF128[34..0],COMPARE $000000000,$400000000
                ,PASS;
            IF ( ! (PASS==1) ) THEN GOTO Label_121;
            NVMPOLL = 10000;
            Label_121:
            IF ( ! (PASS!=1) ) THEN GOTO Label_122;
            IRSCAN 8, $b8;
            WAIT DRPAUSE, 100 USEC, DRPAUSE;
            Label_122:
            LABEL_SEPARATOR = 0;
        NEXT NVMPOLL;
        IF ( ! (PASS==1) ) THEN GOTO VERIFY_ECC_LABEL_PRIV;
        IF ( ! ( (BUFF128[33]==1)&&(BUFF128[32]==0)) ) THEN GOTO VERIFY_CC_PRIV;
        PRINT "ERROR: 2 or more errors found on page: ",PAGEADDRESS,". Please try reprogramming.";
        STATUS = -39;
        IF ( ! (NVMACTIVEARRAY==1) ) THEN GOTO Label_123;
        UNIQUEEXITCODE = 32897;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT_ACCESS_NVM;
        Label_123:
        IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO Label_124;
        UNIQUEEXITCODE = 32898;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT;
        Label_124:
        LABEL_SEPARATOR = 0;
        VERIFY_CC_PRIV:
        IF ( ! (BUFF128[3]==1) ) THEN GOTO VERIFY_WC_PRIV;
        PRINT "WARNING: Write count threshold exceeded on page: ",PAGEADDRESS,".";
        VERIFY_WC_PRIV:
        LABEL_SEPARATOR = 0;
        VERIFY_ECC_LABEL_PRIV:
        IF ( ! (PASS==0) ) THEN GOTO NVMADDRSHIFTOK_0_PRIV;
        PRINT "Failed to verify system init and boot clients.";
        STATUS = 11;
        IF ( ! (NVMACTIVEARRAY==1) ) THEN GOTO Label_125;
        UNIQUEEXITCODE = 32899;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT_ACCESS_NVM;
        Label_125:
        IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO Label_126;
        UNIQUEEXITCODE = 32900;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT;
        Label_126:
        LABEL_SEPARATOR = 0;
        NVMADDRSHIFTOK_0_PRIV:
        FOR I = 0 TO 31;
            BUFF128[34..0] = $000000000;
            BUFF128[31..0] = NVMDATAPRIV_ALL[(NVMDATAINDEX+31)..NVMDATAINDEX];
            IRSCAN 8, $b7;
            DRSCAN 35, $000000000;
            WAIT 3 CYCLES;
            WAIT 30 USEC, DRPAUSE;
            FOR NVMPOLL = 0 TO 100;
                DRSCAN 35, $000000000, CAPTURE NVMCAPTURE[34..0],COMPARE BUFF128[34..0]
                    ,$6ffffffff,PASS;
                IF ( ! (PASS==1) ) THEN GOTO Label_127;
                NVMPOLL = 10000;
                Label_127:
                IF ( ! (PASS!=1) ) THEN GOTO Label_128;
                IRSCAN 8, $b7;
                WAIT DRPAUSE, 50 USEC, DRPAUSE;
                Label_128:
                LABEL_SEPARATOR = 0;
            NEXT NVMPOLL;
            IF ( ! (PASS==0) ) THEN GOTO CONTCOMPARENVM_PRIV;
            PRINT "Failed to verify system boot and init clients.";
            EXPORT "NvmAddress", NVMADDRESS[];
            EXPORT "ExpData", BUFF128[31..0];
            EXPORT "CapData", NVMCAPTURE[31..0];
            EXPORT "CapDataStat", NVMCAPTURE[34..32];
            CALL DISP_SF_USER_ADDR;
            PRINT "Page Offset: ",I;
            PRINT "Word: ",PARWORDCOUNT;
            STATUS = 11;
            IF ( ! (NVMACTIVEARRAY==1) ) THEN GOTO Label_129;
            UNIQUEEXITCODE = 32901;
            BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
            EXPORT "ERROR_CODE", BUFF128[15..0];
            CALL DO_EXIT_ACCESS_NVM;
            Label_129:
            IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO Label_130;
            IF ( ! ( ( ( (ULULR==1)&&(ULFLR==1))&&(ULUPC==1))&&(SECKEY_OK==0)) ) THEN GOTO NO_PAGE_PROTECTION_VER_PRIV;
            PRINT "eNVM is protected with a pass key. A valid pass key needs to be provided.";
            UNIQUEEXITCODE = 32909;
            BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
            EXPORT "ERROR_CODE", BUFF128[15..0];
            STATUS = -57;
            CALL DO_EXIT;
            NO_PAGE_PROTECTION_VER_PRIV:
            UNIQUEEXITCODE = 32902;
            BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
            EXPORT "ERROR_CODE", BUFF128[15..0];
            CALL DO_EXIT;
            Label_130:
            LABEL_SEPARATOR = 0;
            CONTCOMPARENVM_PRIV:
            NVMDATAINDEX = (NVMDATAINDEX+32);
        NEXT I;
        PAGEADDRESS = (PAGEADDRESS+1);
        PARWORDCOUNT = (PARWORDCOUNT+32);
        NVMWORDCOUNT = (NVMWORDCOUNT+32);
        IF ( ! (((NVMWORDCOUNT/32)%PAGEITERATION)==0) ) THEN GOTO Label_131;
        PERCENT_UPDATE = ((100*NVMWORDCOUNT)/NVMWORDS);
        DIFFERENCE = (PERCENT_UPDATE%10);
        IF ( ! (DIFFERENCE>=5) ) THEN GOTO ROUND_DOWN_VER_NVM_PRIV;
        PERCENT_UPDATE = (PERCENT_UPDATE+(10-DIFFERENCE));
        ROUND_DOWN_VER_NVM_PRIV:
        IF ( ! (DIFFERENCE<5) ) THEN GOTO ROUND_UP_VER_NVM_PRIV;
        PERCENT_UPDATE = (PERCENT_UPDATE-DIFFERENCE);
        ROUND_UP_VER_NVM_PRIV:
        EXPORT "PERCENT_DONE", PERCENT_UPDATE;
        Label_131:
        LABEL_SEPARATOR = 0;
    NEXT IREPEAT_6;
ENDPROC;

PROCEDURE DO_PROGRAM_NVM_ALL USES NVM_V,GV,DO_EXIT,DO_EXIT_ACCESS_NVM,DISP_SF_USER_ADDR
    ,DO_PROGRAM_NVM_PRIV;
    IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO ACTIVE_PGM_NVM_ALL;
    CALL DO_PROGRAM_NVM_PRIV;
    ACTIVE_PGM_NVM_ALL:
    IF ( ! (NVMDATASTREAMSIZE_ALL>0) ) THEN GOTO SKIP_PGM_NVM_MSG_ALL;
    PRINT "Program Embedded Flash Memory Module ALL....";
    SKIP_PGM_NVM_MSG_ALL:
    NVMWORDS = (NVMDATASTREAMSIZE_ALL/32);
    NVMPAGES = (NVMWORDS/32);
    NVMWORDCOUNT = 0;
    NVMDATAINDEX = 0;
    NVMADDRESS[] = $000000000;
    NVMADDRESS[12..11] = $2;
    PROTECTION[] = $00;
    PAR = -1;
    PARWORDCOUNT = 0;
    PARSIZE = 0;
    IF ( ! (NVMPAGES>0) ) THEN GOTO SKIP_PGM_NVM_ALL;
    INTEGER IREPEAT_7;
    FOR IREPEAT_7 = NVMPAGES - 1 TO 0 STEP -1;
        IF ( ! (PARWORDCOUNT==PARSIZE) ) THEN GOTO Label_132;
        PARWORDCOUNT = 0;
        PAR = (PAR+1);
        NVMADDRESS[34..13] = NVMADDR_ALL[(((PAR+1)*22)-1)..(PAR*22)];
        NVMADDRESS[20] = 0;
        PAGEADDRESS = INT(NVMADDRESS[34..21]);
        PARSIZE = INT(NVMPARSIZE_ALL[(((PAR+1)*32)-1)..(PAR*32)]);
        PROTECTION[4..2] = NVMPROTECT_ALL[(((PAR+1)*3)-1)..(PAR*3)];
        Label_132:
        BUFF32[31..0] = BOOL(PAGEADDRESS);
        NVMADDRESS[34..21] = BUFF32[13..0];
        IRSCAN 8, $b8;
        DRSCAN 35, NVMADDRESS[];
        WAIT 3 CYCLES;
        WAIT 20 USEC, DRPAUSE;
        FOR NVMPOLL = 0 TO 10000;
            DRSCAN 35, NVMADDRESS[], CAPTURE BUFF128[34..0],COMPARE $000000000,$400000000
                ,PASS;
            IF ( ! (PASS==1) ) THEN GOTO Label_133;
            NVMPOLL = 10000;
            Label_133:
            IF ( ! (PASS!=1) ) THEN GOTO Label_134;
            IRSCAN 8, $b8;
            WAIT DRPAUSE, 100 USEC, DRPAUSE;
            Label_134:
            LABEL_SEPARATOR = 0;
        NEXT NVMPOLL;
        IF ( ! (PASS==0) ) THEN GOTO NVMADDRSHIFTOK_1_ALL;
        PRINT "Error programming Embedded Flash Memory Block (EFMB).";
        STATUS = 10;
        IF ( ! (NVMACTIVEARRAY==1) ) THEN GOTO Label_135;
        UNIQUEEXITCODE = 32873;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT_ACCESS_NVM;
        Label_135:
        IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO Label_136;
        UNIQUEEXITCODE = 32874;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT;
        Label_136:
        LABEL_SEPARATOR = 0;
        NVMADDRSHIFTOK_1_ALL:
        FOR I = 1 TO 32;
            IRSTOP IRPAUSE;
            DRSTOP DRPAUSE;
            IRSCAN 8, $b9;
            DRSCAN 32, NVMDATA_ALL[(NVMDATAINDEX+31)..NVMDATAINDEX];
            WAIT IDLE, 3 CYCLES;
            WAIT IDLE, 5 USEC;
            NVMDATAINDEX = (NVMDATAINDEX+32);
        NEXT I;
        IRSCAN 8, $ba;
        DRSCAN 5, PROTECTION[];
        WAIT 3 CYCLES;
        WAIT 100 USEC, DRPAUSE;
        FOR NVMPOLL = 0 TO 10000;
            DRSCAN 5, PROTECTION[], CAPTURE BUFF128[4..0],COMPARE $00,$10,PASS;
            IF ( ! (PASS==1) ) THEN GOTO Label_137;
            NVMPOLL = 10000;
            Label_137:
            IF ( ! (PASS!=1) ) THEN GOTO Label_138;
            IRSCAN 8, $ba;
            WAIT DRPAUSE, 100 USEC, DRPAUSE;
            Label_138:
            LABEL_SEPARATOR = 0;
        NEXT NVMPOLL;
        IF ( ! ( (BUFF128[2]==1)&&(BUFF128[3]==1)) ) THEN GOTO Label_139;
        PRINT "WARNING: Write count threshold exceeded: ",PAGEADDRESS,".";
        Label_139:
        IF ( ! (PASS==0) ) THEN GOTO CONTPROG_ALL;
        PRINT "Error programming Embedded Flash Memory Block (EFMB).";
        PRINT "Partition : ",PAR;
        PRINT "Word: ",PARWORDCOUNT;
        CALL DISP_SF_USER_ADDR;
        EXPORT "BUSY", BUFF128[4..4];
        EXPORT "PrgStat", BUFF128[3..2];
        EXPORT "NvmStat", BUFF128[1..0];
        BUFF32[31..0] = BOOL(PAGEADDRESS);
        NVMADDRESS[34..21] = BUFF32[];
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $b8;
        DRSCAN 35, NVMADDRESS[];
        WAIT IDLE, 3 CYCLES;
        WAIT IDLE, 20 USEC;
        DRSCAN 35, $000000000, CAPTURE BUFF128[34..0];
        IF ( ! (BUFF128[0]==1) ) THEN GOTO Label_140;
        PRINT "Overwrite Protect ON";
        Label_140:
        IF ( ! (BUFF128[1]==1) ) THEN GOTO Label_141;
        PRINT "Write Protect ON";
        Label_141:
        IF ( ! (BUFF128[2]==1) ) THEN GOTO Label_142;
        PRINT "Read Protect ON";
        Label_142:
        IF ( ! (BUFF128[0]!=1) ) THEN GOTO Label_143;
        PRINT "Overwrite Protect OFF";
        Label_143:
        IF ( ! (BUFF128[1]!=1) ) THEN GOTO Label_144;
        PRINT "Write Protect OFF";
        Label_144:
        IF ( ! (BUFF128[2]!=1) ) THEN GOTO Label_145;
        PRINT "Read Protect OFF";
        Label_145:
        STATUS = 10;
        IF ( ! (NVMACTIVEARRAY==1) ) THEN GOTO Label_146;
        UNIQUEEXITCODE = 32876;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT_ACCESS_NVM;
        Label_146:
        IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO Label_147;
        UNIQUEEXITCODE = 32877;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT;
        Label_147:
        LABEL_SEPARATOR = 0;
        CONTPROG_ALL:
        PAGEADDRESS = (PAGEADDRESS+1);
        PARWORDCOUNT = (PARWORDCOUNT+32);
        NVMWORDCOUNT = (NVMWORDCOUNT+32);
        IF ( ! (((NVMWORDCOUNT/32)%PAGEITERATION)==0) ) THEN GOTO Label_148;
        PERCENT_UPDATE = ((100*NVMWORDCOUNT)/NVMWORDS);
        DIFFERENCE = (PERCENT_UPDATE%10);
        IF ( ! (DIFFERENCE>=5) ) THEN GOTO ROUND_DOWN_PGM_NVM_ALL;
        PERCENT_UPDATE = (PERCENT_UPDATE+(10-DIFFERENCE));
        ROUND_DOWN_PGM_NVM_ALL:
        IF ( ! (DIFFERENCE<5) ) THEN GOTO ROUND_UP_PGM_NVM_ALL;
        PERCENT_UPDATE = (PERCENT_UPDATE-DIFFERENCE);
        ROUND_UP_PGM_NVM_ALL:
        EXPORT "PERCENT_DONE", PERCENT_UPDATE;
        Label_148:
        LABEL_SEPARATOR = 0;
    NEXT IREPEAT_7;
    SKIP_PGM_NVM_ALL:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_VERIFY_NVM_ALL USES NVM_V,GV,DO_EXIT,DO_EXIT_ACCESS_NVM,DISP_SF_USER_ADDR
    ,DO_VERIFY_NVM_PRIV;
    IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO ACTIVE_VER_NVM_ALL;
    CALL DO_VERIFY_NVM_PRIV;
    ACTIVE_VER_NVM_ALL:
    IF ( ! (NVMDATASTREAMSIZE_ALL>0) ) THEN GOTO SKIP_VER_NVM_MSG_ALL;
    PRINT "Verify Embedded Flash Memory Module ALL...";
    SKIP_VER_NVM_MSG_ALL:
    NVMWORDS = (NVMDATASTREAMSIZE_ALL/32);
    NVMPAGES = (NVMWORDS/32);
    NVMWORDCOUNT = 0;
    NVMDATAINDEX = 0;
    NVMADDRESS[] = $000000000;
    NVMADDRESS[12..11] = $2;
    PROTECTION[] = $00;
    PAR = -1;
    PARWORDCOUNT = 0;
    PARSIZE = 0;
    IF ( ! (NVMPAGES>0) ) THEN GOTO SKIP_VERIFY_NVM_ALL;
    INTEGER IREPEAT_8;
    FOR IREPEAT_8 = NVMPAGES - 1 TO 0 STEP -1;
        IF ( ! (PARWORDCOUNT==PARSIZE) ) THEN GOTO Label_149;
        PARWORDCOUNT = 0;
        PAR = (PAR+1);
        NVMADDRESS[34..13] = NVMADDR_ALL[(((PAR+1)*22)-1)..(PAR*22)];
        NVMADDRESS[20] = 0;
        PAGEADDRESS = INT(NVMADDRESS[34..21]);
        PARSIZE = INT(NVMPARSIZE_ALL[(((PAR+1)*32)-1)..(PAR*32)]);
        PROTECTION[4..2] = NVMPROTECT_ALL[(((PAR+1)*3)-1)..(PAR*3)];
        Label_149:
        BUFF32[31..0] = BOOL(PAGEADDRESS);
        NVMADDRESS[34..21] = BUFF32[13..0];
        IRSCAN 8, $b8;
        DRSCAN 35, NVMADDRESS[];
        WAIT 3 CYCLES;
        WAIT 20 USEC, DRPAUSE;
        FOR NVMPOLL = 0 TO 10000;
            DRSCAN 35, NVMADDRESS[], CAPTURE BUFF128[34..0],COMPARE $000000000,$400000000
                ,PASS;
            IF ( ! (PASS==1) ) THEN GOTO Label_150;
            NVMPOLL = 10000;
            Label_150:
            IF ( ! (PASS!=1) ) THEN GOTO Label_151;
            IRSCAN 8, $b8;
            WAIT DRPAUSE, 100 USEC, DRPAUSE;
            Label_151:
            LABEL_SEPARATOR = 0;
        NEXT NVMPOLL;
        IF ( ! (PASS==1) ) THEN GOTO VERIFY_ECC_LABEL_ALL;
        IF ( ! ( (BUFF128[33]==1)&&(BUFF128[32]==0)) ) THEN GOTO VERIFY_CC_ALL;
        PRINT "ERROR: 2 or more errors found on page: ",PAGEADDRESS,". Please try reprogramming.";
        STATUS = -39;
        IF ( ! (NVMACTIVEARRAY==1) ) THEN GOTO Label_152;
        UNIQUEEXITCODE = 32879;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT_ACCESS_NVM;
        Label_152:
        IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO Label_153;
        UNIQUEEXITCODE = 32880;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT;
        Label_153:
        LABEL_SEPARATOR = 0;
        VERIFY_CC_ALL:
        IF ( ! (BUFF128[3]==1) ) THEN GOTO VERIFY_WC_ALL;
        PRINT "WARNING: Write count threshold exceeded on page: ",PAGEADDRESS,".";
        VERIFY_WC_ALL:
        LABEL_SEPARATOR = 0;
        VERIFY_ECC_LABEL_ALL:
        IF ( ! (PASS==0) ) THEN GOTO NVMADDRSHIFTOK_0_ALL;
        PRINT "Failed to verify Embedded Flash Memory Block (EFMB).";
        STATUS = 11;
        IF ( ! (NVMACTIVEARRAY==1) ) THEN GOTO Label_154;
        UNIQUEEXITCODE = 32882;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT_ACCESS_NVM;
        Label_154:
        IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO Label_155;
        UNIQUEEXITCODE = 32883;
        BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF128[15..0];
        CALL DO_EXIT;
        Label_155:
        LABEL_SEPARATOR = 0;
        NVMADDRSHIFTOK_0_ALL:
        FOR I = 0 TO 31;
            BUFF128[34..0] = $000000000;
            BUFF128[31..0] = NVMDATA_ALL[(NVMDATAINDEX+31)..NVMDATAINDEX];
            IRSCAN 8, $b7;
            DRSCAN 35, $000000000;
            WAIT 3 CYCLES;
            WAIT 30 USEC, DRPAUSE;
            FOR NVMPOLL = 0 TO 100;
                DRSCAN 35, $000000000, CAPTURE NVMCAPTURE[34..0],COMPARE BUFF128[34..0]
                    ,$6ffffffff,PASS;
                IF ( ! (PASS==1) ) THEN GOTO Label_156;
                NVMPOLL = 10000;
                Label_156:
                IF ( ! (PASS!=1) ) THEN GOTO Label_157;
                IRSCAN 8, $b7;
                WAIT DRPAUSE, 50 USEC, DRPAUSE;
                Label_157:
                LABEL_SEPARATOR = 0;
            NEXT NVMPOLL;
            IF ( ! (PASS==0) ) THEN GOTO CONTCOMPARENVM_ALL;
            PRINT "Failed to verify Embedded Flash Memory Block (EFMB).";
            EXPORT "NvmAddress", NVMADDRESS[];
            EXPORT "ExpData", BUFF128[31..0];
            EXPORT "CapData", NVMCAPTURE[31..0];
            EXPORT "CapDataStat", NVMCAPTURE[34..32];
            CALL DISP_SF_USER_ADDR;
            PRINT "Page Offset: ",I;
            PRINT "Word: ",PARWORDCOUNT;
            STATUS = 11;
            IF ( ! (NVMACTIVEARRAY==1) ) THEN GOTO Label_158;
            UNIQUEEXITCODE = 32885;
            BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
            EXPORT "ERROR_CODE", BUFF128[15..0];
            CALL DO_EXIT_ACCESS_NVM;
            Label_158:
            IF ( ! (NVMACTIVEARRAY==0) ) THEN GOTO Label_159;
            IF ( ! ( ( ( (ULULR==1)&&(ULFLR==1))&&(ULUPC==1))&&(SECKEY_OK==0)) ) THEN GOTO NO_PAGE_PROTECTION_VER_ALL;
            PRINT "eNVM is protected with a pass key. A valid pass key needs to be provided.";
            UNIQUEEXITCODE = 32914;
            BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
            EXPORT "ERROR_CODE", BUFF128[15..0];
            STATUS = -57;
            CALL DO_EXIT;
            NO_PAGE_PROTECTION_VER_ALL:
            UNIQUEEXITCODE = 32886;
            BUFF128[15..0] = BOOL(UNIQUEEXITCODE);
            EXPORT "ERROR_CODE", BUFF128[15..0];
            CALL DO_EXIT;
            Label_159:
            LABEL_SEPARATOR = 0;
            CONTCOMPARENVM_ALL:
            NVMDATAINDEX = (NVMDATAINDEX+32);
        NEXT I;
        PAGEADDRESS = (PAGEADDRESS+1);
        PARWORDCOUNT = (PARWORDCOUNT+32);
        NVMWORDCOUNT = (NVMWORDCOUNT+32);
        IF ( ! (((NVMWORDCOUNT/32)%PAGEITERATION)==0) ) THEN GOTO Label_160;
        PERCENT_UPDATE = ((100*NVMWORDCOUNT)/NVMWORDS);
        DIFFERENCE = (PERCENT_UPDATE%10);
        IF ( ! (DIFFERENCE>=5) ) THEN GOTO ROUND_DOWN_VER_NVM_ALL;
        PERCENT_UPDATE = (PERCENT_UPDATE+(10-DIFFERENCE));
        ROUND_DOWN_VER_NVM_ALL:
        IF ( ! (DIFFERENCE<5) ) THEN GOTO ROUND_UP_VER_NVM_ALL;
        PERCENT_UPDATE = (PERCENT_UPDATE-DIFFERENCE);
        ROUND_UP_VER_NVM_ALL:
        EXPORT "PERCENT_DONE", PERCENT_UPDATE;
        Label_160:
        LABEL_SEPARATOR = 0;
    NEXT IREPEAT_8;
    SKIP_VERIFY_NVM_ALL:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE RESET_M3;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $96;
    DRSCAN 2, $2;
    WAIT IDLE, 1 CYCLES;
    WAIT RESET, 5 CYCLES;
    EXIT 0;
ENDPROC;


CRC D8C9;
